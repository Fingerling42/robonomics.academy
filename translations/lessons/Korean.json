{
  "Part 3: Emergence of the World Computer": "제 3부: 세계 컴퓨터의 등장",
  "In the third part titled \"Emergence of the World Computer,\" we will attempt, layer by layer, to recreate the engineering implementation of the world computer using examples from Ethereum and Polkadot, as before.\"": "\"세계 컴퓨터의 등장\"이라는 세 번째 파트에서 우리는 이전과 같이 이더리움과 폴카닷의 예시를 사용하여 세계 컴퓨터의 공학 구현을 층층이 재현해 보려 합니다.",
  "Learn": "배우기",
  "In the third part titled \"Emergence of the World Computer,\" we will attempt, layer by layer, to recreate the engineering implementation of the world computer using examples from Ethereum and Polkadot, as before.": "\"세계 컴퓨터의 등장\"이라는 세 번째 파트에서 우리는 이전과 같이 이더리움과 폴카닷의 예시를 사용하여 세계 컴퓨터의 공학 구현을 층층이 재현해 보려 합니다.",
  "Let's start with Ethereum. Ethereum began in 2015 with a state that can be characterized as a combination of the proof-of-work consensus algorithm, enabling the world computer to exist in a decentralized state (as discussed in Part 2). Additionally, the Ethereum Virtual Machine (EVM) was introduced, serving as a Turing-complete computational machine. Together, these two elements formed the first version of the world computer, sometimes referred to as a precursor. Within this context, decentralized applications, or smart contracts, began to emerge.": "우리는 이더리움부터 시작해 보겠습니다. 이더리움은 2015년에 시작되었으며, 이는 프루프 오브 워크 합의 알고리즘의 조합으로 특징 지을 수 있는 상태로 시작되었습니다. 이는 세계 컴퓨터가 분산 상태에서 존재할 수 있도록 하는 것이었습니다(제 2부에서 논의한 것과 같습니다). 게다가, 이더리움 가상 머신(EVM)이 소개되었는데, 이는 튜링 완전한 계산 머신으로 작용했습니다. 이 두 요소가 결합하여 세계 컴퓨터의 첫 번째 버전을 형성했으며, 때로는 선구자로 불리기도 합니다. 이 맥락에서 분산 애플리케이션 또는 스마트 계약이 등장하기 시작했습니다.",
  "Over the next 5 years, Ethereum lived a relatively unchanged life, undergoing some engineering tunings, such as a continuous increase in gas limits, with the exception of events like the Shanghai fork. Notably, during the second DEFCON held in Shanghai, a denial-of-service attack exploited a function in the virtual machine that consumed minimal gas but triggered significant computations on the Ethereum network. This led to memory overflow, effectively disrupting an entire Ethereum node. This incident highlights the intricate details that arise when dealing with a large and abstract solution like creating a virtual machine.": "이후 5년 동안, 이더리움은 상대적으로 변화 없이 살아가다가, 연속적인 가스 한도 증가와 같은 몇 가지 공학 조정을 거쳤습니다. 상하이 포크와 같은 사건을 제외하고는요. 특히, 상하이에서 개최된 두 번째 DEFCON에서 가상 머신의 기능을 악용한 서비스 거부 공격이 발생했는데, 이는 최소한의 가스를 소비하면서 이더리움 네트워크에서 중요한 계산을 유발하는 기능을 이용했습니다. 이로 인해 메모리 오버플로우가 발생하여 전체 이더리움 노드를 마비시켰습니다. 이 사건은 가상 머신을 만드는 등 대규모이고 추상적인 솔루션을 다룰 때 발생하는 복잡한 세부 사항을 강조합니다.",
  "Moving forward, a significant shift occurred around the end of the decade, particularly in 2020, with the advent of Ethereum 2.0. However, Ethereum 2.0 has now been deprecated, and I would characterize the real breakthrough as starting around 2019-2020. During this period, there was a true technological breakthrough in Ethereum, moving towards the concept of Ethereum 2.0. The moment of engineering change in Ethereum's architecture can be considered the event known as \"the merge,\" where the functionalities of the beacon chain were combined. The merge marked a significant shift in the paradigm of Ethereum, transitioning it into a slightly different state than what was on the board. The actual engineering change in Ethereum's architecture can be associated with \"the merge,\" where the functionalities of the beacon chain were integrated. For a detailed history of this, you can refer to the ethereum.org website, which provides an excellent article on the coexistence of the traditional Ethereum blockchain with the parallel blockchain launched in 2015 and the Ethereum Virtual Machine.": "앞으로, 2020년을 중심으로 특히 2020년에 이더리움 2.0이 출현함으로써 10년이 넘는 시간 동안 중요한 변화가 일어났습니다. 그러나 이제 이더리움 2.0은 폐기되었으며, 실제로 2019-2020년쯤부터 진정한 기술적 돌파가 시작되었다고 평가할 수 있습니다. 이 기간 동안 이더리움에서 진정한 기술적 돌파가 있었는데, 이는 이더리움 2.0 개념으로 나아가는 것이었습니다. 이더리움의 아키텍처에서의 공학적 변화의 순간은 \"합병\"이라고 알려진 이벤트로 볼 수 있습니다. 합병은 비컨 체인의 기능이 결합된 것을 의미하며, 이는 이더리움의 패러다임에 중대한 변화를 가져왔습니다. 이더리움의 아키텍처에서의 실제 공학적 변화는 비컨 체인의 기능이 통합된 \"합병\"과 관련이 있습니다. 이에 대한 자세한 역사는 2015년에 시작된 병렬 블록체인과 함께 전통적인 이더리움 블록체인의 공존에 대한 훌륭한 기사를 제공하는 ethereum.org 웹사이트를 참조하실 수 있습니다.",
  "When the merge occurred, we witnessed a new architectural representation, both at the network level and for individual nodes interacting with the Ethereum network. What was the actual change? For many, the merge signifies the transition from proof-of-work to proof-of-stake, which is indeed significant. It implies increased efficiency and fine-tuning, but it's still a tuning relative to one of the parameters. However, the more noteworthy internal engineering change for each network client was the split. There was no longer a single specific network client or a monolithic architecture. Instead, we got two components of a single node interacting with the Ethereum network.": "병합이 발생할 때, 우리는 네트워크 수준과 이더리움 네트워크와 상호 작용하는 개별 노드에 대한 새로운 건축적 표현을 목격했습니다. 실제 변경 사항은 무엇이었습니까? 많은 사람들에게 병합은 작업 증명에서 지분 증명으로의 전환을 의미하며, 이는 실제로 중요합니다. 이것은 향상된 효율성과 세밀한 조정을 함축하지만, 여전히 매개 변수 중 하나에 대한 조정입니다. 그러나 각 네트워크 클라이언트에 대한 더 주목할 만한 내부 엔지니어링 변경 사항은 분할이었습니다. 더 이상 특정 네트워크 클라이언트나 단일적인 아키텍처가 없었습니다. 대신, 우리는 이더리움 네트워크와 상호 작용하는 단일 노드의 두 구성 요소를 얻었습니다.",
  "The first part, which I labeled \"beacon chain\" on the diagram, essentially represents a collective image of all the innovations that came into the Ethereum client at the moment of the merge. The second part is the preserved virtual machine. Nevertheless, it's worth adding something here too. Dialogues truly began about replacing the virtual machine, which was exclusively tailored to work with smart contracts and smart contracts in a specific language—Solidity. This is because, by 2015, there were practically no interpreters left for smart contracts in languages other than Solidity, and the architecture appeared somewhat one-sided from the perspective of an Ethereum programmer. You learn a snippet of JavaScript in the form of Solidity, write smart contract code on it, and get your DApp, like Uniswap, for example.": "도표에서 '비컨 체인'이라고 라벨링한 첫 번째 부분은 병합 시 이더리움 클라이언트에 들어온 모든 혁신들의 집합적 이미지를 본질적으로 나타냅니다. 두 번째 부분은 보존된 가상 머신입니다. 그럼에도 불구하고 여기에도 무언가 추가하는 것이 가치가 있습니다. 가상 머신을 대체하는 대화가 실제로 시작되었는데, 이는 스마트 계약 및 특정 언어인 솔리디티로 작업하기 위해 특별히 제작된 가상 머신을 대체하는 것에 대한 대화였습니다. 이겪은 이유는 2015년까지 솔리디티 이외의 언어로 스마트 계약을 하는 인터프리터가 거의 없었기 때문이었고, 이 아키텍처는 이더리움 프로그래머의 관점에서 어느 정도 편향된 것으로 보였습니다. 솔리디티 형태의 자바스크립트 스니펫을 배우고, 그 위에 스마트 계약 코드를 작성하여 Uniswap과 같은 DApp을 얻었습니다.",
  "Since the emergence of a more complex Ethereum architecture, discussions have revolved around the idea that the virtual machine, which existed as a somewhat monolithic element from 2015, can also be replaced in the new architecture. The conversation shifted towards replacing it with something like WebAssembly (Wasm) or a more interesting solution from the perspective of writing code for the world computer. You could say, \"Wasm with a question mark.\"": "더 복잡한 이더리움 아키텍처가 등장한 이후, 가상 머신이 2015년부터 어느 정도 단일적인 요소로 존재했던 것을 대체할 수도 있다는 아이디어를 중심으로 토론이 진행되었습니다. 대화는 웹어셈블리(Wasm)와 같은 것으로 대체하거나 세계 컴퓨터를 위한 코드 작성 관점에서 더 흥미로운 해결책으로 이동했습니다. \"물음표가 붙은 Wasm\"이라고 말할 수 있습니다.",
  "From the perspective of the Beacon Chain, it indeed operates on proof-of-stake, but what's more interesting is the inclusion of Gasper. This represents a modification of the original ideas about Casper. Casper, often referred to as the friendly ghost finality gadget, was introduced, perhaps even as early as Defcon 3 or 4, and maybe even discussed at Defcon 2—I don't recall precisely. But at the EthCC conference in Paris, which definitely took place in 2018, Vlad Zamfir and Vitalik, from different rooms, were discussing the emergence of Casper as a friendly ghost, overseeing participants in proof-of-stake and coming to the aid of the network when a node misbehaves. From this idea of Casper, Gasper emerges. Without delving into terminology too much, the consensus algorithm undergoes a shift, changing not only in terms of simplicity but also becoming more complex, similar to Polkadot. As I mentioned earlier, Polkadot has two consensus algorithms, Babe and Grandpa. Similarly, with Ethereum's Beacon Chain functionality, achieving consensus and finality is not as instantaneous. It involves epochs, and the network operates on a more complex scenario, reaching a state that is already somewhat dynamic, not frozen, and is essentially carved in stone.": "비컨 체인의 관점에서, 이는 실제로 지분 증명에서 작동하지만, 더 흥미로운 것은 Gasper의 포함입니다. 이것은 Casper에 대한 원래 아이디어를 수정한 것입니다. Casper는 종종 친근한 유령 최종성 가젯으로 불리며, 아마도 Defcon 3 또는 4에서 소개되었을 것이고, 아마도 Defcon 2에서도 논의되었을 수도 있습니다—정확히 기억나지 않습니다. 그러나 2018년 파리에서 열린 EthCC 컨퍼런스에서 Vlad Zamfir와 Vitalik은 Casper가 친근한 유령으로 등장하여 지분 증명 참가자들을 감시하고 노드가 잘못 행동할 때 네트워크를 지원하는 것에 대해 논의하고 있었습니다. Casper의 이 아이디어에서 Gasper가 등장합니다. 용어에 너무 깊이 파고들지 않고, 합의 알고리즘은 단순성 측면뿐만 아니라 Polkadot과 유사하게 더 복잡해지는 변화를 겪습니다. 앞서 언급한 대로, Polkadot은 Babe와 Grandpa 두 합의 알고리즘을 가지고 있습니다. 마찬가지로, 이더리움의 비컨 체인 기능을 통해 합의와 최종성을 달성하는 것은 즉각적이지 않습니다. 시대가 있으며, 네트워크는 더 복잡한 시나리오에서 작동하며, 이미 어느 정도 동적이고 얼어붙지 않은 상태에 도달하며 본질적으로 돌파됩니다.",
  "What can be added in relation to 2024? For me, it was a prolonged observation and an attempt to understand whether Ethereum would eventually implement sharding or not. Sharding is the ability to exist not with a single blockchain but with multiple blockchains within one network. As I observed the merge and the simultaneous rise of Layer 2 (L2) networks, questions arose in my mind about whether sharding would indeed materialize. Sharding seemed interesting to me due to its homogeneity—having multiple chains that are almost identical, lacking any specific characteristics. It appeared to be an interesting approach, but not as flexible as a heterogeneous approach. In L2 networks, even several years ago, I could see the heterogeneity of Ethereum, its ability to work with various types of more specific blockchains. I was curious about the direction it would take—whether sharding, with its homogeneity, would displace L2 solutions or whether L2 solutions with a heterogeneous approach would saturate the Beacon Chain and the main nodes of the Ethereum network.": "2024년에 관련하여 추가할 수 있는 것은 무엇인가? 나에게는 이더리움이 최종적으로 샤딩을 구현할 것인지 여부를 이해하려는 장기간의 관찰과 시도였습니다. 샤딩은 단일 블록체인이 아닌 하나의 네트워크 내에서 여러 블록체인이 존재할 수 있는 능력입니다. 병합과 동시에 L2 네트워크의 동시적인 상승을 관찰하면서, 샤딩이 실제로 구현될 것인지에 대한 의문이 생겼습니다. 샤딩은 동질성 때문에 흥미로웠는데, 거의 동일한 특성을 가진 여러 체인이 존재하고 특정 특성이 없었습니다. 이는 흥미로운 접근 방식으로 보였지만, 이질적인 접근 방식만큼 유연하지는 않았습니다. 몇 년 전에도 L2 네트워크에서 이더리움의 이질성, 다양한 유형의 더 구체적인 블록체인과 작동할 수 있는 능력을 볼 수 있었습니다. 어떤 방향으로 나아갈지—샤딩이 동질성 때문에 L2 솔루션을 대체할 것인지, 아니면 이질성 접근 방식을 가진 L2 솔루션이 비컨 체인과 이더리움 네트워크의 주요 노드를 포화시킬 것인지에 대한 궁금증이 있었습니다.",
  "Today, in 2024, based on articles on ethereum.org, it seems that sharding as a concept has been pushed back, and the focus is on helping various L2 networks integrate with the Beacon Chain and align with the main chain's functionality, which is now divided into two elements in the Ethereum network's architecture.": "2024년 현재, ethereum.org의 기사를 기반으로 보면, 샤딩이라는 개념은 밀려나고, 다양한 L2 네트워크가 비컨 체인과 조화를 이루고 주요 체인의 기능과 일치하도록 돕는 데 초점이 맞춰져 있는 것으로 보입니다. 이는 이제 이더리움 네트워크 아키텍처에서 두 요소로 분할된 주요 체인과 조화를 이루는 다양한 L2 네트워크를 돕는 것에 초점이 맞춰져 있습니다.",
  "Therefore, without delving into the details of how L2 networks are structured—although we'll touch upon that when we fill in the second part of the board—we should imagine that Ethereum is now a kind of Beacon Chain, a beacon, a guiding star for numerous L2 networks. These L2 networks can have more specific functionality, executing their logic according to a set of individual functions. This is somewhat in line with the idea of a Swiss Army knife—not making Ethereum a Swiss Army knife, but L2 networks are starting to differentiate in architecture. They duplicate the functionality of the abstract computing machine of Ethereum but perform it with lower gas costs or within their specific segment. Some are already thinking about tuning and making their L2 layer more efficient, focusing on specific functional capabilities. Thus, in my opinion, we are witnessing the emergence of heterogeneity in the world computer that aimed to be homogeneous. Also, it's essential not to forget that decentralized applications (dApps) still exist within the main blockchain, within that same blockchain that started in 2015. This means that during the merge, during the transition to the new architectural state, there was no wipeout, no erasure of the previous history. All decentralized applications and smart contracts underlying these applications continued to exist, and they continue to exist today, and probably tomorrow. This is a question that we will explore using Polkadot as an example, but there is still a feeling that it will be possible to settle a decentralized application in the Beacon Chain—dApps.": "그러므로, L2 네트워크가 어떻게 구성되는지에 대한 세부 내용에 대해 깊이 파고들지 않고도 - 우리가 보드의 두 번째 부분을 채울 때 그에 대해 언급할 것이지만 - 우리는 이제 이더리움이 종류의 비콘 체인, 비콘, 다수의 L2 네트워크를 위한 안내성 별자리로 상상해야 합니다. 이러한 L2 네트워크는 더 구체적인 기능을 가질 수 있으며, 개별 기능 집합에 따라 그들의 논리를 실행할 수 있습니다. 이것은 스위스 아미 나이프의 개념과 어느 정도 일치합니다 - 이더리움을 스위스 아미 나이프로 만드는 것이 아니라, L2 네트워크는 아키텍처에서 차이를 시작하고 있습니다. 이들은 이더리움의 추상 컴퓨팅 기계의 기능을 복제하지만 더 낮은 가스 비용으로 또는 그들의 특정 세그먼트 내에서 수행합니다. 일부는 이미 L2 레이어를 튜닝하고 더 효율적으로 만들고 특정 기능 능력에 초점을 맞추고 있습니다. 따라서 내 의견으로는, 우리는 동질적이었던 세계 컴퓨터에서 이질성이 나타나고 있다고 보고 있습니다. 또한, 탈중앙화 애플리케이션 (dApps)이 여전히 2015년에 ��작된 동일한 블록체인 내에서 존재한다는 것을 잊지 말아야 합니다. 이는 병합 중에, 새로운 아키텍처 상태로의 전환 중에, 이전 역사의 삭제나 소거가 없었다는 것을 의미합니다. 모든 탈중앙화 애플리케이션 및 이러한 애플리케이션의 기반이 되는 스마트 계약은 계속해서 존재했으며, 오늘도 존재하고 있으며, 아마도 내일도 존재할 것입니다. 이것은 우리가 폴카닷을 예로 들어 탐색할 문제이지만, 아직도 비콘 체인 내에 탈중앙화 애플리케이션을 처리할 수 있을 것이라는 느낌이 있다.",
  "In summary, let's imagine the engineering implementation of today's Ethereum as a world computer. We have each network node consisting of two parts. The first layer is responsible for the Ethereum Virtual Machine (EVM), the actual functionality of the virtual machine or Turing complete machine, if we talk in theoretical terms. Perhaps we will see the emergence of alternatives to the virtual machine designed in 2015. These alternatives will likely surpass it in terms of more abstract programming possibilities than writing smart contracts in Solidity. Meanwhile, smart contracts in Solidity continue to feel comfortable. If you want to write functionality for the Ethereum main chain without creating any infrastructure on top of Ethereum, without offloading any calculations to make them cheaper, and so on, decentralized applications that you can write as smart contracts can still be housed in Ethereum's main blockchain. At the same time, Beacon Chain functionality has emerged, separating the consensus logic between validators from the main protocol of the computing machine. This allows for additional flexibility in how consensus should work and how it should be further modified without affecting the virtual machine itself. The example of Shanghai and Defcon 2, where a small opcode error caused a shutdown of part of the infrastructure, hints that it would be good to have such complex functionalities separated into two parts.": "요약하면, 오늘의 이더리움의 공학 구현을 세계 컴퓨터로 상상해 봅시다. 우리는 두 부분으로 구성된 각 네트워크 노드를 가지고 있습니다. 첫 번째 레이어는 이더리움 가상 머신 (EVM)을 담당하며, 실제 기능을 하는 가상 머신 또는 이론적으로 말하면 튜링 완전 기계입니다. 아마도 2015년에 설계된 가상 머신에 대한 대안이 등장할 것입니다. 이러한 대안들은 아마도 Solidity로 스마트 계약을 작성하는 것보다 더 추상적인 프로그래밍 가능성 측면에서 그것을 능가할 것입니다. 한편, Solidity로 작성된 스마트 계약은 여전히 편안하게 느껴집니다. 이더리움의 상위 레이어를 만들지 않고도 이더리움 위에 인프라를 만들지 않고도 계산을 오프로드하지 않고도 이더리움의 주요 체인에 대한 기능을 작성하려면, Solidity로 작성된 스마트 계약으로 작성할 수 있는 탈중앙화 애플리케이션은 여전히 이더리움의 주요 블록체인에 있을 수 있습니다. 동시에, 비콘 체인 기능이 등장하여, 검증자 간의 합의 논리를 컴퓨팅 기계의 주요 프로토콜에서 분리시켰습니다. 이는 합의가 어떻게 작동해야 하는지 및 가상 머신 자체에 영향을 미치지 않고 어떻게 더 수정해야 하는지에 대한 추가적인 유연성을 제공합니다. 작은 옵코드 오류로 일부 인프라의 종료를 유발한 상하이와 Defcon 2의 예는 이러한 복잡한 기능을 두 부분으로 분리하는 것이 좋을 것이라는 신호를 줍니다.",
  "What's interesting about the Beacon Chain? It is a more complex, comprehensive algorithm for achieving network synchronicity and finalization with the introduction of concepts such as \"epoch,\" and the presence of a ghost living within the network.": "비콘 체인에 대해 흥미로운 점은 무엇인가요? 네트워크 동기화와 최종화를 달성하기 위한 더 복잡하고 포괄적인 알고리즘으로, \"에포크\"와 네트워크 내에 존재하는 유령과 같은 개념이 소개되었습니다.",
  "Lastly, what is important to consider now is that Ethereum is effectively putting an end to homogeneity, to the idea of getting a hundred identical blockchains working with the same virtual machine, where smart contracts written in Solidity can reside. Instead, various projects are proposing their own architectures or the same virtual machine taken beyond the main blockchain's limits. Alternatively, they are trying to build their more specific application, which, at the level of the Beacon Chain's main chain, is a smart contract written in Solidity. This is the current representation of Ethereum, which did not become Ethereum 2.0. It remains the same Ethereum—a project that once started with proof of work + Turing complete machine, transforming into this architecture.": "마지막으로, 지금 고려해야 할 중요한 점은 이더리움이 동질성에 종지부를 찍고, 백 개의 동일한 블록체인이 동일한 가상 머신에서 작동하는 아이디어에 종지부를 찍고 있다는 것입니다. 대신, 다양한 프로젝트들은 자체 아키텍처를 제안하거나 주요 블록체인의 한계를 넘어서는 동일한 가상 머신을 취하려고 합니다. 또는 더 구체적인 응용 프로그램을 구축하려고 하며, 이것은 비콘 체인의 주요 체인 수준에서 Solidity로 작성된 스마트 계약입니다. 이것이 현재의 이더리움의 표현이며, 이더리움 2.0이 되지 않은 이더리움입니다. 이것은 변하지 않은 이더리움입니다 - 한 때 작업 증명 + 튜링 완전 기계로 시작한 프로젝트가 이러한 아키텍처로 변화한 것입니다.",
  "Now, let's take a look at how Polkadot emerged and evolved over the last 5 years. Polkadot came into existence five years after Ethereum, born out of the team that developed one of the best clients for Ethereum—Parity. Many might remember their web client, which, compared to Geth and other implementations, was probably much more pleasant to work with, at least from personal experience and the experience of colleagues.": "지금, 우리는 Polkadot이 지난 5년 동안 어떻게 출현하고 발전해 왔는지 살펴보겠습니다. Polkadot은 이더리움 후 5년 후에 탄생했으며, 이더리움을 위한 최고의 클라이언트 중 하나를 개발한 팀에서 탄생했습니다 - Parity. 많은 사람들은 그들의 웹 클라이언트를 기억할 것이며, Geth 및 다른 구현과 비교했을 때, 적어도 개인 경험 및 동료들의 경험에서 훨씬 더 쾌적했을 것입니다.",
  "In the end, after a couple of months of the relay chain's existence without any decentralized application functionality, without the ability to connect your parachain or L2 network, without user capabilities, the network transitioned from an authority state to proof of stake. This gave developers the ability to upload their runtimes.": "최종적으로, 분산 애플리케이션 기능 없이 릴레이 체인이 존재한 몇 달 후, 파라체인이나 L2 네트워크를 연결할 수 없고 사용자 기능이 없었던 상태에서 네트워크는 권한 상태에서 지분 증명으로 전환되었습니다. 이로써 개발자들은 자신들의 런타임을 업로드할 수 있게 되었습니다.",
  "At this point, it's also interesting to discuss the differences between today's Ethereum and how the central part of Polkadot is structured. From the perspective of the heart, which we've already discussed, the picture will be absolutely the same not only for Ethereum and Polkadot but for any project that wants to be presented as an abstract computing machine. However, from an engineering and architectural standpoint, it's fascinating to observe Beacon Chain & Relay Chain. Here, we have a virtual machine, which has been inherited since 2015, but alternatives are being proposed. In the relay chain, there's the ability to upload your runtime. The runtime is, in fact, your virtual machine. For example, some parachains completely emulate the Ethereum Virtual Machine. It's written as a runtime, meaning you can essentially upload an Ethereum Virtual Machine analog to the parachain level in Polkadot or write more specific logic that works with four or five functions. Recall part one about the ideas— you can write your Swiss Army knife, but it won't require creating the entire infrastructure. You can implement specific functionality with certain functions at the runtime level, put it into the Polkadot relay chain, and the immutability of this runtime will be ensured by Polkadot validators.": "이 시점에서 오늘날의 이더리움과 Polkadot의 중심 부분이 어떻게 구성되어 있는지에 대해 토론하는 것도 흥미로울 것입니다. 이미 논의한 중심부분의 관점에서는 이더리움과 Polkadot 뿐만 아니라 추상 컴퓨팅 기계로 나타내고자 하는 모든 프로젝트에 대해 그림은 절대로 동일할 것입니다. 그러나 공�� 및 구조적인 측면에서는 Beacon Chain & Relay Chain을 관찰하는 것이 흥미로울 것입니다. 여기에는 2015년부터 상속된 가상 머신이 있지만 대안이 제안되고 있습니다. 릴레이 체인에서는 자신의 런타임을 업로드할 수 있습니다. 런타임은 사실상 가상 머신입니다. 예를 들어, 일부 파라체인은 완전히 이더리움 가상 머신을 에뮬레이트합니다. 런타임으로 작성되어 있으므로, Polkadot의 파라체인 수준에 이더리움 가상 머신 아날로그를 업로드하거나 네 가지 또는 다섯 가지 기능과 함께 작동하는 더 구체적인 논리를 작성할 수 있습니다. 아이디어에 대한 제1부를 상기하십시오 - 스위스 아미 나이프를 작성할 수 있지만 전체 인프라를 생성할 필요는 없습니다. 런타임 수준에서 특정 기능을 구현하고, Polkadot 릴레이 체인에 넣으면 이 런타임의 불변성은 Polkadot 검증자들에 의해 보장될 것입니다.",
  "What happens next? Over the course of about a year, a layer of parachains begins to form around the relay chain. In terms of Ethereum implementation, you could say that L2 networks are quite similar to parachains. However, there's one interesting cross-network distinction that I find fascinating in Polkadot, and I'm trying to further understand how it will develop—namely, the second layer of validation and data availability checks. After a couple of years, Polkadot takes a shape like this. It's not just a relay chain where proof-of-stake validators protect the runtime of future parachains; an additional and crucial layer of data validation and availability checking emerges from parachains.": "다음에는 무엇이 일어날까요? 약 1년 동안, 릴레이 체인 주변에 패러체인의 층이 형성되기 시작합니다. 이더리움 구현 관점에서 L2 네트워크는 패러체인과 매우 유사하다고 할 수 있습니다. 그러나 폴카닷에서 흥미로운 교차 네트워크 구분 중 하나는 두 번째 계층의 검증 및 데이터 가용성 확인이라고 생각하는데, 이것이 어떻게 발전할지 더 이해하려고 노력하고 있습니다. 몇 년 후, 폴카닷은 이렇게 모습을 갖게 됩니다. 이것은 미래 패러체인의 런타임을 보호하는 스테이크 검증자들이 있는 릴레이 체인뿐만 아니라, 패러체인에서 나오는 데이터 유효성 검증 및 가용성 확인의 추가적이고 중요한 계층이 나타납니다.",
  "As you look at this diagram, try to notice the analogies that arise and the differences in engineering implementation details. So, what does this represent, and how does this scheme compare with Ethereum? We have an L2 project, in this case, with Polkadot, it's a parachain. A parachain also generates information blocks, which then go to the relay chain to be combined and release a relay chain block as the sum of all headers, headers, and more headers. The parachain collects transactions in a block using collators, which are not involved in validation. They don't stake anything in the relay chain; they only use the runtime, which is in the relay chain. They fetch it, apply it to transactions, perform necessary state transitions, form a block, and, crucially, provide proof of validity—a stamp containing cryptographic proofs that the collator correctly assembled the block. This information goes to the external validation ring of the relay chain. In this ring, there are internal validators of Polkadot—parachain collators. Again, they don't stake anything directly from the relay chain's point of view. Parachain implementations sometimes introduce their consensus among collators, and some don't. For example, in Robonomics, implementing a parachain, we find this paradigm more interesting, less burdensome, and it makes the network simpler while still remaining functionally substantial. Any collator, without reaching consensus with anyone—verified by us—can propose a block and some proof to the external layer. This is precisely why blocks are proposed, proofs of block assembly validity are offered, and there's an external ring. We don't need any consensus from parachain validators. Anyone can generate a block and send it, and if this node of the collator sends incorrect information to the parachain validators on the external ring, the validator at this level will reject it. It won't pass into the central part. But let's say the block was provided correctly by the collator. Our transactions got in; the collator calculated them, applying the runtime stored in the relay chain, executed all state transitions, gathered some proof of validity—validity of the assembled block—and passed it to the external ring of the relay chain. Here, every epoch, which is also part of the finalization, every epoch has validators from the relay chain diverging into parachains. Some of them stay in the center, and the others go to parachains. Their number ranges from 16 to 64 validators, and this figure, I believe, will change in the specification—somewhere more, somewhere less. However, parachain validators re-verify the information from one selected group of validators about everything coming from the collator being correct, that work has been done in accordance with the runtime, and that the proof of validity is indeed valid. The selected segment of relay chain validators who already have something staked respond, or rather, chirp among themselves. They respond to the chosen main block producer of the parachain, so to speak, saying,": "이 다이어그램을 보면, 비교적 유사한 비유와 엔지니어링 구현 세부 사항의 차이점을 주목해보세요. 그래서 이것이 무엇을 나타내고, 이 계획이 이더리움과 어떻게 비교되는지 알아보세요. 우리는 이 경우에 폴카닷과 함께 L2 프로젝트를 가지고 있습니다. 이것은 패러체인입니다. 패러체인은 정보 블록을 생성하고, 그 블록은 릴레이 체인��로 이동하여 모든 헤더, 헤더 및 더 많은 헤더의 합으로 릴레이 체인 블록을 발행합니다. 패러체인은 콜렉터를 사용하여 블록에서 트랜잭션을 수집합니다. 콜렉터는 검증에 참여하지 않습니다. 그들은 릴레이 체인에 아무것도 스테이크하지 않습니다. 그들은 릴레이 체인에 있는 런타임만 사용합니다. 그것을 가져와서 트랜잭션에 적용하고 필요한 상태 전이를 수행하여 블록을 형성하고, 중요한 것은 유효성 증명을 제공하는 것입니다. 이 유효성 증명에는 콜렉터가 블록을 올바르게 조립했다는 암호학적 증거가 포함되어 있습니다. 이 정보는 릴레이 체인의 외부 검증 링으로 이동합니다. 이 링에는 폴카닷의 내부 검증자인 패러체인 콜렉터가 있습니다. 다시 말하지만, 그들은 릴레이 체인의 관점에서 직접 아무것도 스테이크하지 않습니다. 패러체인 구현은 때로는 콜렉터들 사이에서 자체 합의를 소개하고, 어떤 경우에는 그렇지 않습니다. 예를 들어, 패러체인을 구현하는 Robonomics에서 이 패러체인을 구현하는 패러체인에서 이 패러다임을 더 흥미롭고 부담 없게 만들고 네트워크를 더 단순하게 유지하면서도 기능적으로 중��하게 만듭니다. 어떤 콜렉터도 아무도와 합의에 도달하지 않고 우리가 확인한 채로 블록을 제안하고 외부 계층에 일부 증거를 제공할 수 있습니다. 이것이 바로 왜 블록이 제안되고 블록 조립의 유효성 증명이 제공되며 외부 링이 있는지입니다. 우리는 패러체인 검증자들로부터 어떤 합의도 필요하지 않습니다. 누구나 블록을 생성하고 보낼 수 있으며, 이 콜렉터 노드가 외부 링의 패러체인 검증자들에게 잘못된 정보를 보내면 이 수준의 검증자는 그것을 거부할 것입니다. 중앙 부분으로 전달되지 않습니다. 그러나 블록이 콜렉터에 의해 올바르게 제공되었다고 가정해 봅시다. 우리의 트랜잭션이 들어갔고, 콜렉터가 이를 계산하여 릴레이 체인에 저장된 런타임을 적용하고 모든 상태 전이를 실행하고 유효성 증명 - 조립된 블록의 유효성 - 을 수집하여 릴레이 체인의 외부 링으로 전달했습니다. 여기서 매 에포크마다, 이것은 최종화의 일부이기도 한데, 각 에포크마다 릴레이 체인에서 패러체인으로 발산하는 검증자들이 있습니다. 그들 중 일부는 중앙에 머물러 있고, 다른 일부는 패러체인으로 이동합니다. 그들의 수는 16에��� 64명의 검증자로 이루어져 있으며, 이 수치는 제언에서 변할 것으로 믿습니다 - 어디선가는 더 많고, 어디선가는 더 적을 것입니다. 그러나 패러체인 검증자들은 콜렉터로부터 온 모든 정보에 대해 선택된 일부 검증자 그룹으로부터 정보를 재확인하고, 그 정보가 런타임과 일치하게 작업이 수행되었으며, 유효성 증명이 실제로 유효한지 확인합니다. 이미 스테이크된 릴레이 체인 검증자들의 선택된 세그먼트는 서로 응답하거나, 다시 말해, 서로 속삭입니다. 그들은 패러체인의 선택된 주요 블록 프로듀서에게 응답하여, 이를 통해 말하자면, ",
  "\"Yes, we agree. There are no problems. You can carry it through the entire external ring inside.\"": "\"예, 동의합니다. 문제가 없습니다. 전체 외부 링 내부로 이동할 수 있습니다.\"",
  "And thus, almost all information formed on the parachain collators, with verification on the external ring, enters the internal one. The lower part, not that it's physically at the bottom, still constitutes the external ring—data availability. Data starts to be checked at this stage, meaning that on the external ring, not only the correctness of block assembly is verified, but the process of preparing for distribution within the Polkadot network begins, ensuring that the block information will not be lost in the future. Here, precisely, is what I mentioned in the second part about chunks, like CD RW. At this stage of block preparation for transfer to the internal ring, the data availability layer is formed as a service, something that is currently also attempted by some projects in Ethereum. Some projects put additional redundant information directly into smart contracts, necessary for checking what is happening on the L2 layer and, if necessary, slashing or punishing those who did it incorrectly. It's impossible to overcome the external ring without distributing block information and without rechecking dozens of nodes with stakes laid down on the assumption that the runtime must work correctly.": "그리고 따라서, 거의 모든 정보가 파라체인 콜렉터에서 형성되며 외부 링에서 확인을 건너뛰어 내부 링으로 들어갑니다. 하단 부분은 실제로 맨 아래에 있는 것은 아니지만 외부 링인 데이터 가용성을 구성합니다. 데이터는 이 단계에서 확인되기 시작하며, 외부 링에서는 블록 조립의 정확성뿐만 아니라 Polkadot 네트워크 내에서 분배를 위한 준비 과정도 확인되어 블록 정보가 미래에 손실되지 않도록 보장됩니다. 여기에서 바로 제가 두 번째 부분에서 언급한 청크, CD RW와 같은 것입니다. 내부 링으로 전송 준비를 위한 블록 준비 단계에서 데이터 가용성 레이어가 서비스로 형성되며, 현재 일부 이더리움 프로젝트에서도 시도 중입니다. 일부 프로젝트는 L2 레이어에서 무엇이 발생하는지 확인하고 필요한 경우 잘못된 작업을 한 사람들을 벌하는 데 필요한 추가 중복 정보를 스마트 계약에 직접 넣습니다. 런타임이 올바르게 작동해야 한다는 가정에 기반을 둔 수십 개의 노드를 다시 확인하지 않고 블록 정보를 분배하지 않고 외부 링을 극복하는 것은 불가능��니다.",
  "Thus, information that has passed through the external ring is already quite trustworthy, probably yes, you can say that, and on the internal ring, work is mainly done not with parachain blocks, but their block headers are collected into one big header. That is, from many headers, one header of a relay chain block is assembled—a mechanism of linking in Shared Security, as mentioned in Polkadot, which ensures the security of parachains. One could say that parachains are validated and reach a state where the service exists in a distributed decentralized form on the external ring. In the internal ring, the information that has entered attempts to come together in one hyperblock, which should precisely link everything together. There are no calculations happening there; there is no recalculation of absolutely everything. The assembly of the final block takes place, so to speak, in the current iteration of the world computer, to put a point on the question of whether the transaction has passed in a particular parachain. We must assemble a hyperblock that contains not all the information from the parachains but gathers all the headers verified on the external ring of parachains into one large block. And thus, our world computer in Polkadot operates.": "따라서, 외부 링을 통과한 정보는 이미 상당히 신뢰할 만하며, 내부 링에서는 주로 파라체인 블록이 아니라 그 블록 헤더가 하나의 큰 헤더로 수집됩니다. 즉, 여러 헤더에서 릴레이 체인 블록의 하나의 헤더가 조립됩니다. 이는 Polkadot에서 언급된 Shared Security의 링크 메커니즘으로, 파라체인의 보안을 보장합니다. 파라체인이 검증되어 외부 링에서 분산된 분산형 형태로 서비스가 존재하는 상태에 도달합니다. 내부 링에서 들어온 정보는 모두 하이퍼블록으로 모이려고 시도하며, 이는 모든 것을 정확하게 연결해야 합니다. 거기서 계산이 일어나지 않으며, 절대적으로 모든 것을 다시 계산하지 않습니다. 최종 블록의 조립이 이루어지며, 현재 세계 컴퓨터의 반복에서 특정 파라체인에서 거래가 성공적으로 이루어졌는지에 대한 질문에 마침표를 찍습니다. 우리는 모든 파라체인에서 모든 정보를 포함하지 않는 하이퍼블록을 조립해야 하며, 외부 링에서 검증된 모든 헤더를 하나의 큰 블록으로 모아야 합니다. 그리고 따라서, Polkadot의 세계 컴퓨터가 작동합니다.",
  "Let's take another look at these two schemes together: relay chain, beacon chain, runtime, secured by proof of stake, where someone stakes their funds to validate that they will always perform their work correctly. There's a virtual machine where you can also stake your funds, and if you perform any computation or state transition not in accordance with the Ethereum Virtual Machine's specification, you'll be penalized.": "이 두 가지 체계를 함께 다시 살펴 보겠습니다: 릴레이 체인, 비컨 체인, 런타임, 스테이크로 보호된 프루프 오브 스테이크, 누군가가 자신의 자금을 스테이크하여 항상 올바르게 작업을 수행할 것을 검증합니다. 자금을 스테이크할 수 있는 가상 머신이 있으며, 이더리움 가상 머신의 사양에 따라 어떤 계산이나 상태 전이를 수행하지 않으면 처벌받게 됩니다.",
  "In Polkadot, there's an additional external layer, which seems to be one of the main advantages, such pleasant perks of the engineering implementation that, in my opinion, should be present here. It should appear between L2 networks and the beacon chain, which exists in Ethereum. By the way, some say that the term \"beacon chain\" is dying out again and is misunderstood, but I really like to use it in analogy with the \"relay chain,\" a term from Ethereum's roadmap.": "폴카닷에는 L2 네트워크와 이더리움에 존재하는 비컨 체인 사이에 나타나야 할 추가적인 외부 계층이 있습니다. 엔지니어링 구현의 즐거운 혜택 중 하나로 보입니다. 어떤 사람들은 \"비컨 체인\"이 다시 사라지고 오해받고 있다고 말하지만, 저는 이 용어를 이더리움의 로드맵에서 나온 \"릴레이 체인\"과 유사성을 비유하는 것을 정말 좋아합니다.",
  "And perhaps one more interesting story in this part of the lecture: so far, we can hardly imagine proper cross-chain messages between L2 networks in Ethereum. Maybe I missed something in the papers, but when you don't have an external ring and issues like collators, paravalidators, and data availability services are not resolved, thinking about how two L2 layers can communicate is challenging. Yet, in Polkadot, it exists. Even horizontally, through the relay chain, meaning directly, one can send a transaction securely from one parachain to another, without trusting any bridges between these two parachains. This is another crucial functionality that will likely need to be implemented at the level of connecting L2 networks. Smart contracts in Ethereum communicate well. We have created many chains of linked smart contracts, where one triggers another. With this, there is no problem. But when we say that almost all applications are moving to the L2 layer in a heterogeneous network, I hear that if you live in a specific area, you won't be able to get out. That's not the case at the level of parachains and implementation in Polkadot. Both architectures are worth watching, as, in my opinion, the engineering implementation follows the mainstream path of becoming a global computer. They differ slightly, but there are many similarities. There's an enormous amount of engineering work everywhere. As we see, human civilization, in the form of a multitude of researchers, engineers, and growing developers with significant resources for further development, is moving roughly in the same direction from the smallest early stage to probably some future establishment of the world's computer, all on the same tracks.": "그리고 이 강의의 이 부분에서 더 흥미로운 이야기 하나 더 있을지도 모르겠습니다: 지금까지 우리는 이더리움의 L2 네트워크 간 적절한 크로스 체인 메시지를 상상하기 어려웠습니다. 논문에서 놓친 부분이 있을 수도 있지만, 외부 링이 없고 콜렉터, 파라밸리데이터, 데이터 가용성 서비스와 같은 문제가 해결되지 않은 상황에서 두 L2 레이어가 어떻게 통신할 수 있는지 생각하는 것은 어려운 일입니다. 그런데 Polkadot에서는 그것이 가능합니다. 심지어 중계 체인을 통해 수평적으로, 즉 직접적으로 한 패러체인에서 다른 패러체인으로 안전하게 거래를 보낼 수 있습니다. 이 두 패러체인 사이에 다리를 믿지 않고도 가능합니다. 이것은 아마도 L2 네트워크를 연결하는 수준에서 구현해야 할 또 다른 중요한 기능입니다. 이더리움의 스마트 계약은 잘 통신합니다. 우리는 서로 트리거하는 많은 연결된 스마트 계약 체인을 만들었습니다. 이것으로는 문제가 없습니다. 그러나 거의 모든 응용 프로그램이 이종 네트워크의 L2 레이어로 이동하고 있다고 말할 때, 특정 ���역에 살고 있다면 나갈 수 없을 것이라고 듣습니다. 그러나 패러체인 수준과 Polkadot의 구현에서는 그렇지 않습니다. 두 아키텍처는 주목할 가치가 있습니다. 내 의견으로는 엔지니어링 구현이 글로벌 컴퓨터가 되는 주류 경로를 따르고 있다고 생각합니다. 약간 차이가 있지만 많은 유사점이 있습니다. 엔지니어링 작업이 엄청난 양으로 이루어지고 있습니다. 우리가 볼 수 있듯이, 인류 문명은 수많은 연구자, 엔지니어, 그리고 발전을 위한 상당한 자원을 가진 개발자들의 형태로, 아마도 세계 컴퓨터의 미래 설립에 이르기까지, 모두 같은 방향으로 대략 이동하고 있습니다.",
  "Part 1: The Idea of a World Computer": "제1부: 세계 컴퓨터의 아이디어",
  "This is the first part of a four-part lecture titled \"World Computer in Your Home.\" In the first part, titled \"The Idea of a World Computer,\" I want to analyze and share my own reflections that have, in a broader historical context, gathered around the hashtag \"world computer.\"": "이것은 '당신의 집에 있는 세계 컴퓨터'라는 제목의 네 부작 강의 중 첫 번째 부분입니다. 첫 번째 부분인 '세계 컴퓨터의 아이디어'에서는 '세계 컴퓨터' 해시태그 주변에 모인 내 생각을 분석하고 공유하고 싶습니다.",
  "To begin with, let's try to gather a generalized understanding of what a world computer is, without delving into terminology or specific technical details. If you take your mobile phone in hand and look at the icons, you can notice that practically every application on the phone has two major segments or areas of operation.": "우선 용어나 구체적인 기술적 세부 사항에 대해 깊이 파고들지 않고 세계 컴퓨터가 무엇인지에 대한 일반적인 이해를 모아보려고 합니다. 핸드폰을 들고 아이콘을 살펴보면, 핸드폰의 거의 모든 애플리케이션이 두 가지 주요 세그먼트나 작동 영역을 가지고 있다는 것을 알 수 있습니다.",
  "The first is the local part, meaning, for example, your calculator or notes application. This is a completely local application that requires almost no external communication. Although even applications like the notes app on an iPhone are a bit more than that, let's focus on the more austere Open Source side of applications for Android phones, so to speak.": "첫 번째는 로컬 부분으로, 예를 들어 계산기나 메모 애플리케이션입니다. 이것은 완전히 로컬 애플리케이션이며 외부 통신이 거의 필요하지 않습니다. 아이폰의 메모 앱과 같은 애플리케이션조차도 그 이상이지만, 안드로이드 폰용 애플리케이션의 더 엄숙한 오픈 소스 쪽에 초점을 맞추겠습니다.",
  "The second part requires cloud infrastructure, and here, when the question of cloud infrastructure arises, a multitude of quite complex stories begins: who owns this cloud infrastructure, what capabilities do developers have to add features to an application, and in general, how does the user own this application? What capabilities and responsibilities does the user have when dealing with an application that exists not only on their phone but also in some infrastructure beyond their pocket or palm? The world computer is precisely one example of how the developer community responds to these obvious questions. Obvious questions about creating higher-quality applications for your mobile phone, laptop, server, and any other smart device that needs to connect to the network and obtain knowledge from there.": "두 번째 부분은 클라우드 인프라가 필요하며, 여기서 클라우드 인프라 문제가 제기되면 상당히 복잡한 이야기가 시작됩니다: 누가 이 클라우드 인프라를 소유하고 있으며 개발자들은 애플리케이션에 기능을 추가할 수 있는 능력이 있으며 사용자가 이 애플리케이션을 소유하는 방법은 무엇인가? 사용자가 핸드폰뿐만 아니라 주머니나 손바닥 너머의 인프라에도 존재하는 애플리케이션을 다룰 때 사용자가 가지는 능력과 책임은 무엇인가? 세계 컴퓨터는 개발자 커뮤니티가 이러한 명백한 질문에 대한 대답으로 어떻게 반응하는지의 한 예입니다. 모바일폰, 노트북, 서버 및 네트워크에 연결하고 거기서 지식을 얻어야 하는 다른 스마트 기기에 대한 더 높은 품질의 애플리케이션을 만드는 것에 대한 명백한 질문에 대한 대답입니다.",
  "The world computer is, accordingly, the same cloud, the same infrastructure that exists on the internet, with which developers can interact and publish their applications. As a user, you can install, download, and run them on your PC. However, with one interesting, crucial feature: no one actually owns the infrastructure or cloud of the world computer. There is no specific company, jurisdiction, or individual on Earth who can determine and say whether you can publish your application there or not, whether you have the right to access this world computer infrastructure to receive the provided service. Therefore, the world computer is a cloud in which any developer can place their application, and any user with access solely to the internet network and not to a specific IP address behind a firewall can use the application by paying for computations from their pocket.": "세계 컴퓨터는 따라서 인터넷에 존재하는 동일한 클라우드, 동일한 인프라입니다. 개발자는 이를 통해 상호 작용하고 응용 프로그램을 게시할 수 있습니다. 사용자로서 PC에 설치, 다운로드 및 실행할 수 있습니다. 그러나 흥미로운 중요한 기능 하나가 있습니다. 실제로 세계 컴퓨터의 인프라나 클라우드를 소유한 사람은 아무도 없습니다. 세계 컴퓨터의 인프라를 소유하거나 클라우드를 소유하거나 결정하고 게시할 수 있는지 여부를 말할 수 있는 특정 회사, 관할권 또는 지구상의 개인이 없습니다. 따라서 세계 컴퓨터는 어떤 개발자도 자신의 응용 프로그램을 배치할 수 있는 클라우드이며, 인터넷 네트워크에만 액세스할 수 있는 사용자는 방화벽 뒤의 특정 IP 주소에 액세스할 수 없으며 지불하여 응용 프로그램을 사용할 수 있습니다.",
  "Here's the story in a generalized format. There is no mention of \"blockchain,\" no mention of \"smart contracts,\" but these concepts are underneath. Let's still acknowledge: a world computer is a cloud infrastructure that is sovereign, owned by no one, allowing each developer to avoid censorship from platform owners offering app downloads. It also prevents users from being in a situation where they don't understand how an app works on their phone. In my opinion, these are important and cool features deserving respect and attention from those who want to create more futuristic, cooler applications. This is precisely what my team and I have been doing for eight years, choosing perhaps the most challenging area - creating services for robotics on the world computer, which seems to be right outside your door, quietly scraping and saying, \"I want to come into your home.\"": "일반화된 형식으로 이야기를 해보겠습니다. \"블록체인\"이나 \"스마트 계약\"에 대한 언급은 없지만 이러한 개념은 그 아래에 있습니다. 여전히 인정해야 할 점은 세계 컴퓨터가 누구의 소유도 아닌 주권을 가진 ��라우드 인프라라는 것이며, 각 개발자가 앱 다운로드를 제공하는 플랫폼 소유자로부터 검열을 피할 수 있습니다. 또한 사용자가 핸드폰에서 어떻게 앱이 작동하는지 이해하지 못하는 상황에 놓이지 않도록 합니다. 내 의견으로는 이러한 중요하고 멋진 기능들은 미래 지향적이고 더 멋진 응용 프로그램을 만들고자 하는 사람들로부터 존경과 주의를 받아야 합니다. 이것이 바로 저와 제 팀이 8년 동안 해온 일이며 아마도 가장 어려운 분야를 선택했습니다. 세계 컴퓨터에서 로봇 서비스를 위한 서비스를 만드는 것은 문득 당신의 문 밖에 있어 조용히 긁고 \"당신의 집에 들어오고 싶어\"라고 말하는 것 같습니다.",
  "Now, let's move on to a timeline and look through my personal experience at how the concept of the world computer evolved. First, let's go back to 2012. This year is notable because Bitcoin already exists as a global internet service, accessible to everyone, not owned by anyone specific. By 2012, besides Bitcoin, its so-called forks start appearing. One of the most well-known is Litecoin.": "이제 타임라인으로 넘어가서 세계 컴퓨터 개념이 어떻게 발전해 왔는지 제 개인적인 경험을 살펴보겠습니다. 먼저 2012년으로 돌아가 봅시다. 이 해는 비트코인이 이미 전 세계적으로 인터넷 서비스로 존재하고 누구에게나 접근 가능하며 특정한 소유자가 없는 것으로 유명합니다. 2012년에는 비트코인 외에도 그 이른바 포크가 나타나기 시작했습니다. 가장 잘 알려진 것 중 하나는 라이트코인입니다.",
  "Litecoin is notable because its developer did the most important work for the entire community. He collected the most crucial configurable variables or constants from different parts of Bitcoin's code after the protocol was launched. This allowed specifying block generation time, block reward, and, statistically, Litecoin is more frequently forked than Bitcoin. When we say \"fork of Bitcoin,\" I can confidently say that, in most cases, it will be a fork of Litecoin.": "라이트코��은 개발자가 비트코인 코드의 다양한 부분에서 가장 중요한 구성 변수나 상수를 수집한 후 프로토콜이 시작된 후에 가장 중요한 작업을 수행했습니다. 이를 통해 블록 생성 시간, 블록 보상을 지정할 수 있었으며 통계적으로 라이트코인은 비트코인보다 더 자주 포크되었습니다. \"비트코인의 포크\"라고 말할 때 대부분의 경우 라이트코인의 포크일 것이라고 자신 있게 말할 수 있습니다.",
  "Namecoin is also a fork of Bitcoin, and if memory serves me right, it was initially a direct fork from Bitcoin, and then Litecoin appeared a few months later in 2011. However, Namecoin turned out to be a bit different, paving the way for many developers mentally on where ideas underlying Bitcoin's internet service could evolve. Namecoin went beyond being just a coin; it could store identity as a database and allow an internet service to place your domain name. This was the first example where an internet service spawned from Bitcoin could have a different nature, not just like Litecoin with fast transactions but the ability to pay for storing certain information with its internal currency, an internal token. For example, the name in the .bit domain zone.": "Namecoin은 또한 비트코인의 포크이며, 내 기억이 맞다면, 처음에는 비트코인에서 직접 포크되었고, 그 후 2011년에 몇 달 후에 라이트코인이 나타났습니다. 그러나 Namecoin은 약간 다르게 나타났으며, 비트코인의 인터넷 서비스의 기본 아이디어가 어떻게 발전할 수 있는지에 대해 많은 개발자들에게 영감을 주었습니다. Namecoin은 그냥 동전이 아닌 것으로 나아가, 신원을 데이터베이스로 저장하고 인터넷 서비스가 도메인 이름을 배치할 수 있도록 했습니다. 이것은 비트코인에서 파생된 인터넷 서비스가 빠른 거래만 하는 라이트코인과 같지 않고 내부 통화, 내부 토큰을 사용하여 특정 정보를 저장하기 위해 지불할 수 있는 능력을 가진 첫 번째 예였습니다. 예를 들어, .bit 도메인 영역의 이름.",
  "Developers worldwide were experimenting with Bitcoin, mostly creating forks, making them faster, cheaper electronic cash. Alongside this, the first services appeared, seeing opportunities not only in financial applications but also in cross-industrial applications in other areas like Namecoin. Namecoin provided the first globally accessible and unowned internet service through which you could launch your website without being under the jurisdiction of a specific organization but within a distributed globally accessible network. This moment is crucial for us to move on to the early precursors of the world computer's ideas.": "전 세계 개발자들은 비트코인을 실험하고 있었으며, 대부분 포크를 만들어 더 빠르고 저렴한 전자 현금을 만들고 있었습니다. 이와 함께, 첫 번째 서비스가 나타나기 시작했으며, 금융 응용 프로그램뿐만 아니라 Namecoin과 같은 다른 분야의 교차 산업 응용 프로그램에서��� 기회를 찾았습니다. Namecoin은 특정 조직의 관할권 하에 있지 않고 분산된 전 세계적으로 접근 가능한 네트워크 내에서 웹 사이트를 시작할 수 있는 최초의 전 세계적으로 접근 가능하고 소유하지 않은 인터넷 서비스를 제공했습니다. 이 순간은 우리가 세계 컴퓨터의 초기 선구자로 나아가기 위한 중요한 순간입니다.",
  "The first practical ideas of the world computer emerged in 2014, two years after the appearance of the first wave of Bitcoin forks and the creation of meaningful services dedicated not only to electronic cash but also exploring broader themes. We encounter ideas that precede the launch of Ethereum.": "세계 컴퓨터의 첫 번째 실용적인 아이디어는 2014년에 등장했으며, 첫 번째 비트코인 포크의 첫 파동과 전자 현금뿐만 아니라 보다 넓은 주제를 탐구하는 의미 있는 서비스의 창설 이후 2년이 지난 후에 나타났습니다. 우리는 이더리움 출시 전의 아이디어를 만납니다.",
  "In 2014, at several meetups worldwide, in Miami and, I believe, in Europe, Vitalik Buterin articulated sensible ideas. He suggests that we can develop not just a set of internet services that essentially function as a Swiss army knife, right? We can develop a virtual machine. Those with an education in Computer Science probably remember what an infinite tape is in Turing machines, and if we go back to the theory of computational machines, we probably recall the theoretical origins of creating our personal computers, essentially the server infrastructure we have today. It's interesting that, fifty years after the development of von Neumann architecture and the complete Turing machine theory, and with the dawn of internet technologies only by 2014, and only after experiments with Bitcoin, the first idea emerges on our planet of creating a fully virtual computational machine based on the same theory that has been tested in the computer science industry for the past 50 years. The mechanics are the same as when creating any personal computer or server in a data center, but based more on achievements in internet technologies and the achievements of the world that will later be called Web3.": "2014년에는 마이애미와 유럽에서 여러 모임에서 Vitalik Buterin이 분별 있는 아이디어를 제시했습니다. 그는 우리가 본질적으로 스위스 아미 나이프로 작동하는 인터넷 서비스 집합을 개발할 수 있다고 제안합니다. 우리는 가상 머신을 개발할 수 있습니다. 컴퓨터 과학 교육을 받은 사람들은 튜링 머신의 무한 테이프가 무엇인지 기억할 것이며, 계산 기계 이론으로 돌아가면 우리는 우리 개인 컴퓨터를 만드는 이론적 기원을 기억할 것입니다. 실제로 오늘날의 서버 인프라를 기반으로 하는 개인 컴퓨터나 데이터 센터의 서버를 만들 때와 같은 메커니즘은 동일하지만, 인터넷 기술의 성취와 웹3이라고 나중에 불리울 세계의 성취에 더 기반을 둔 것입니다.",
  "Ethereum itself is not a Swiss army knife, not a set of specific internet services. It is, in the direct sense, a cloud, a computational machine. What lies at its core, I will tell you in the next lecture. Here, the most important thing for us is to focus on where the idea of Ethereum began. It started with the realization that, in two years, dozens of different internet services were invented that were interesting because they were globally accessible, available without censorship for developers to deploy. Users could use them only with an internal currency. However, what was not liked in all these concepts was that almost every interesting service required its own massive distributed infrastructure. Unlike familiar internet services, you couldn't just launch your globally accessible infrastructure if you were a very small person or a small team because such a network would be vulnerable, and the service itself would become unsafe. To overcome the problems that were side effects or negative externalities of creating your own globally accessible sovereign internet service, the concept of Ethereum emerged. Ethereum, as a full-fledged cloud capable of handling any formalized computation, allows you to write your program code, a complete program essentially, and run it in the same blockchain alongside hundreds of other applications. This possibility, sounding from the small stages of 2014, naturally captivated the minds of many and seemed absolutely logical for someone with a basic education in Computer Science. If you could understand what Turing completeness was by 2014, if you could envision the historical theory of creating a personal computer, you would definitely not overlook the Ethereum whitepaper and would say that this is exactly what the entire developer community needs.": "이더리움 자체는 스위스식 나이프가 아니며 특정 인터넷 서비스의 집합도 아닙니다. 그것은 직접적인 의미로 구름, 계산 기계입니다. 그 핵심에 무엇이 있는지 다음 강의에서 말하겠습니다. 여기서 우리에게 가장 중요한 것은 이더리움 아이디어가 어디에서 시작되었는지에 초점을 맞추는 것입니다. 이것은 두 해 동안 수십 개의 다양한 인터넷 서비스가 발명되어 전 세계적으로 접근 가능하고 개발자가 검열 없이 배포할 수 있는 흥미로운 서비스들이었다는 깨달음으로 시작되었습니다. 사용자는 내부 통화만으로 그것들을 사용할 수 있었습니다. 그러나 모든 이러한 개념에서 좋아하지 않았던 것은 거의 모든 흥미로운 서비스가 자체 대규모 분산 인프라를 필요로 했다는 것이었습니다. 익숙한 인터넷 서비스와 달리 매우 작은 사람이나 작은 팀이라면 전 세계적으로 접근 가능한 인프라를 간단히 시작할 수 없었기 때문에 그러한 네트워크는 취약해지고 서비스 자체가 안전하지 않아질 것이었습니다. 자체적으로 전 세계적으로 접근 가능한 주권 인터넷 서��스를 만드는 것의 부작용이나 부정적 외부성을 극복하기 위해 이더리움 개념이 등장했습니다. 모든 형식화된 계산을 처리할 수 있는 완전한 클라우드로서 이더리움은 여러분의 프로그램 코드, 본질적으로 완전한 프로그램을 작성하고 수백 개의 다른 응용 프로그램과 함께 동일한 블록체인에서 실행할 수 있게 합니다. 이 가능성은 2014년의 초기 단계에서부터 울려퍼졌으며 많은 사람들의 마음을 사로잡았으며 컴퓨터 과학의 기본 교육을 받은 사람에게는 절대적으로 논리적으로 보였습니다. 2014년까지 튜링 완전성이 무엇인지 이해할 수 있었다면 개인 컴퓨터를 만드는 역사적 이론을 상상할 수 있었다면 이더리움 화이트페이퍼를 놓치지 않고 전체 개발자 커뮤니티가 필요로 하는 것이 정확히 이것이라고 말했을 것입니다.",
  "I believe the year 2014 and Ethereum mark the first, though not explicitly named, instances of the concept of a global computer. It started with the idea that we don't need a Swiss knife; instead, we need infrastructure or a universal cloud that addresses global-level security challenges. Developers, at a low cost, should be able to deploy their applications there without concerning themselves with issues like securing the network or creating a network of providers for this computer or your specific internet service.": "저는 2014년과 이더리움이 전 세계 컴퓨터 개념의 최초이자 명시적으로 명명되지 않은 첫 번째 사례라고 믿습니다. 우리는 스위스 나이프가 필요하지 않고 대신 글로벌 수준의 보안 문제를 해결하는 인프라나 유니버설 클라우드가 필요하다는 아이디어로 시작되었습니다. 개발자들은 낮은 비용으로 애��리케이션을 배포할 수 있어야 하며 네트워크를 보호하거나 이 컴퓨터나 특정 인터넷 서비스를 위한 공급업체 네트워크를 만드는 문제와 같은 문제에 대해 걱정할 필요가 없어야 합니다.",
  "In 2015, Ethereum was effectively launched. From that moment onwards, even until 2020, I haven't encountered significant counterarguments against the idea of creating not just specific internet services but embracing and developing the concept of a virtual computer, virtual server, cloud, or a global computer, as I prefer to call it.": "2015년에 이더리움이 효과적으로 시작되었습니다. 그 순간부터 2020년까지, 나는 특정 인터넷 서비스를 만드는 것뿐만 아니라 가상 컴퓨터, 가상 서버, 클라우드 또는 전 세계 컴퓨터 개념을 받아들이고 발전시키는 것에 대한 중요한 반박을 만나지 않았습니다. 다양한 변형이 나타나며 당시 인기 있던 EOS가 약간 다른 소비 패러다임을 제안했던 것을 기억하는 사람들도 있을 것입니다. 그 프로젝트에 대한 제 개인적인 혐오에도 불구하고 21개의 검증자와 모든 것을 갖춘 것으로 많은 사람들에게 충분했습니다. 그러나 토큰 소유가 대역폭의 일부를 부여한다는 아이디어를 소개했으며, 이는 로보노믹스 아키텍처의 영역에서 오늘날까지 흥미롭게 남아 있습니다.",
  "Various variations emerge, perhaps some remember the then-popular EOS suggesting a slightly different consumption paradigm. Despite my personal aversion to that project, with its 21st validator and all, it seemed sufficient for many. But it introduced the idea that owning tokens grants you a portion of bandwidth, which, in the realm of Robonomics architecture, remains interesting to me to this day.": "다양한 변형이 나타나며, 어쩌면 일부는 그 당시 인기 있던 EOS를 기억할지도 모르겠습니다. 21번째 유효성 검사기와 모든 것을 가진 그 프로젝트에 대한 제 개인적인 혐오에도 불구하고, 많은 사람들에게는 충분해 보였습니다. 그러나 그것은 토큰을 소유하면 대역폭의 일부를 부여받는 아이디어를 소개했으며, 로보노믹스 아키텍처의 영역에서는 오늘날까지도 나에게 흥미롭습니다.",
  "Simultaneously, other ideas on how to modernize the Ethereum network arise. Projects like Definity, Solana, and others come into play. Around the same time, Gavin Wood introduces Polkadot, who assisted Vitalik in creating Ethereum. From a multitude of technological projects between 2015 and 2020, we move from a race to create individual internet service variants to witnessing, on a communication protocol level, the emergence of something like Ethereum killers. Many projects started under this slogan, taking the idea of a unified cloud for multiple internet services and modifying some aspects. For instance, EOS proposed an alternative utilization scheme, where only token-backed ownership allowed access to bandwidth. There were projects where the programming language for writing code was more interesting. For example, during a hackathon for BMW, when we won with an implementation on Ethereum, the automaker immediately stated that we wouldn't go any further unless we had formally verified contracts, which was impossible to achieve on Ethereum at that time.": "동시에, 이더리움 네트워크를 현대화하는 방법에 대한 다른 아이디어가 나옵니다. Definity, Solana 및 기타 프로젝트들이 등장합니다. 동시에 Gavin Wood는 Vitalik을 돕는 Polkadot을 소개합니다. 2015년부터 2020년까지 다양한 기술 프로젝트들 사이에서 우리는 개별 인터넷 서비스 변형을 만드는 경쟁에서, 통신 프로토콜 수준에서 이더리움 킬러와 같은 것이 나타나는 것을 목격합니다. 많은 프로젝트들이 이 슬로건 아래 시작되었고, 여러 인터넷 서비스를 위한 통합 클라우드 아이디어를 채택하고 일부 측면을 수정했습니다. 예를 들어, EOS는 토큰을 보증으로 한 소유권만 대역폭에 액세스할 수 있는 대체 이용 계획을 제안했습니다. 코드 작성을 위한 프로그래밍 언어가 더 흥미로운 프로젝트도 있었습니다. 예를 들어, BMW의 해커톤에서 이더리움을 통해 구현하여 우승한 경우, 자동차 제조업체는 즉시 우리가 형식적으로 검증된 계약을 가지고 있지 않다면 더 나아가지 않을 것이라고 명시했습니다. 이때 이더리움에서는 불가능했습니다.",
  "At this moment, as you read about the ideas of Eternity and other networks, you may think, \"I should try working with them too.\" Service developers understood this, as did, as I mentioned, projects like Definity, which recently launched the World Computer and is gaining traction. Simultaneously, the idea of Polkadot emerges as a heterogeneous multi-chain framework. Ethereum, around the mid-2010s, also received a roadmap for scalability and development. By 2024, almost all concepts converge on the idea of having not just one database or blockchain but a multitude. Various transaction processing methods, two-layer consensus algorithms, optimistic majority approaches, and a plethora of technical implementation variations emerge, all aiming at the same global computer concept.": "현재 당신이 Eternity 및 다른 네트워크의 아이디어에 대해 읽는 동안, \"나도 그들과 함께 일해보아야겠다\"고 생각할 수 있습니다. 서비스 개발자들은 이를 이해했고, 최근 세계 컴퓨터를 출시하고 인기를 얻고 있는 Definity와 같은 프로젝트들도 마찬가지입니다. 동시에, 다양한 체인 프레임워크로 나타나는 Polkadot의 아이디어가 등장합니다. 2010년대 중반쯤, 이더리움도 확장성 및 개발 로드맵을 받았습니다. 2024년까지 거의 모든 개념이 하나의 데이터베이스나 블록체인이 아닌 다양한 것을 가지고 있다는 아이디어로 수렴합니다. 다양한 거래 처리 방법, 이중 계의 알고리즘, 낙관적 다수 접근법 및 다양한 기술 구현 변형이 나타나며, 모두가 동일한 글로벌 컴퓨터 개념을 목표로 합니다.",
  "Let's now go through a timeline snapshot:": "이제 타임라인 스냅샷을 살펴보겠습니다:",
  "**2009-2012**: Emergence of the first globally accessible internet service for electronic cash - Bitcoin.": "**2009-2012**: 전 세계적으로 접근 가능한 전자 현금 인터넷 서비스의 등장 - 비트코인.",
  "**Early 2012**: The first fork war occurs, with projects emerging to replicate similar services. Some multi-billion projects create their forks. Simultaneously, projects like Namecoin propose interesting ideas.": "**초반 2012년**: 첫 번째 포크 전쟁이 발생하며, 유사한 서비스를 복제하기 위해 프로젝트들이 등장합니다. 일부 수십억 달러 규모의 프로젝트들이 자신들의 포크를 만듭니다. 동시에, Namecoin과 같은 프로젝트들이 흥미로운 아이디어를 ��안합니다.",
  "**2014**: The concept of a world computer emerges, requiring a deep understanding of computer science theory and immersion in Bitcoin's development.": "**2014년**: 세계 컴퓨터 개념이 등장하며, 컴퓨터 과학 이론에 대한 심도 있는 이해와 비트코인 개발에 대한 몰입이 필요합니다.",
  "**2015-2020**: The concept moves from theory to practice. Modifications and variations of Ethereum arise, introducing different ideas with varying degrees of quality. The term \"World Computer\" became established.": "**2015-2020년**: 개념이 이론에서 실제로 이동합니다. 이더리움의 수정 및 변형이 나타나며, 다양한 품질의 아이디어가 소개됩니다. \"세계 컴퓨터\"라는 용어가 확립됩니다.",
  "**2024**: We reach the World Computer, a term now well-established, marking the transition from a simple calculator on your phone to a globally accessible institution. The idea of the World Computer encompasses future money, programming money, storage for identification records, and important documents.": "**2024년**: 우리는 이제 잘 알려진 세계 컴퓨터에 도달하며, 단순한 전화기 계산기에서 전 세계적으로 접근 가능한 기관으로의 전환을 표시합니다. 세계 컴퓨터의 아이디어는 미래의 화폐, 프로그래밍 화폐, 식별 레코드 및 중요 문서의 저장소를 포함합니다.",
  "In conclusion, from a simple calculator to a globally accessible institution, the idea of the World Computer has evolved. It's seen as a place for the future of money and the storage of vital records. The concept of a World Computer has progressed from theoretical discussions to practical engineering implementations. In the next lecture, the discussion will delve into what a World Computer actually represents. It is fundamentally a state transition function, a concept to be explored further in the upcoming lecture, emphasizing its importance and the need to safeguard it.": "결론적으로, 단순한 계산기에서 전 세계적으로 접근 가능한 기관으로의 세계 컴퓨터 아이디어가 발전했습니다. 이는 미래의 화폐 및 중요 기록의 저장소로 간주됩니다. 세계 컴퓨터의 개념은 이론적인 논의에서 실용적인 엔지니어링 구현으로 진전했습니다. 다음 강의에서는 세계 컴퓨터가 실제로 무엇을 의미하는지에 대해 논의할 것입니다. 이는 본질적으로 상태 전이 함수로, 중요성을 강조하고 보호해야 할 필요성을 강조하는 강의에서 더 탐구해��� 할 개념입니다.",
  "Part 2: The Heart of the World Computer": "제2부: 세계 컴퓨터의 핵심",
  "What lies at the core of projects like Ethereum or Polkadot, or any other web3 project claiming the title of the world computer, and why does the comparison with the heart in the human body fit so well into the abstract architecture of the world computer?": "이더리움 또는 폴카닷과 같은 프로젝트의 핵심에는 무엇이 있으며, 세계 컴퓨터라는 제목을 주장하는 다른 웹3 프로젝트와 인간 신체의 심장과의 비교가 왜 세계 컴퓨터의 추상적 아키텍처에 잘 맞는지에 대해 알아보겠습니다.",
  "Let's try to understand these questions in this part of the lecture, and to begin with, we'll have to break the chains of Bitcoin maximalists a bit. Most likely, you've already read one or several popular science articles dedicated to Bitcoin in your life, and the main thing that is practically noted everywhere is the three main advantages of Bitcoin as electronic cash:": "이 강의의 이 부분에서 이러한 질문들을 이해해보려고 하며, 먼저, 비트코인 맥시멀리스트들의 사슬을 조금 풀어야 할 것입니다. 아마도 당신은 이미 인생에서 비트코인에 관한 하나 또는 여러 인기 있는 과학 기사를 읽어본 적이 있을 것이고, 거의 모든 곳에서 전자 현금으로서의 비트코인의 세 가지 주요 장점이 거의 어디서나 언급되는 것을 주목했을 것입니다:",
  "Censorship resistance": "검열 저항",
  "Immutability of data stored in the Bitcoin blockchain": "비트코인 블록체인에 저장된 데이터의 불변성",
  "Transparency of transactions": "거래의 투명성",
  "Let's quickly go through each of these properties, and most importantly, at the end, we'll need to step back a bit from them, as the world computer inherits them as some kind of successor to Bitcoin.": "이러한 속성 각각을 빠르게 살펴보겠으며, 무엇보다도, 마지막으로, 세계 컴퓨터가 비트코인의 일종의 후속자로서 이러한 속성을 상속한다는 점에서 조금 물러서야 할 것입니다.",
  "**Firstly**, immutability of data. Of course, this property, from the perspective of electronic cash, has significant advantages and importance. After you send a transaction or receive bitcoins, after one or two blocks, you gradually begin to feel the immutability of data in the blockchain. In the first 15 minutes, you can observe, using a blockchain explorer, how the transaction should settle. You already see it in the network, but it is not finalized, meaning these bitcoins are not yet in your account. However, after several blocks, there is confidence that these funds will not disappear from your account. As time passes, the probability of values being somehow overwritten from your account becomes almost negligible, practically reducing to zero. This is our property of data immutability. How cool it is when you can share information with the recipient, send them a link to the blockchain explorer, and you don't need to obtain any paper or document from the bank stating that you sent a payment on a certain date and time - this is the second advantage of Bitcoin that is very helpful in practice and is probably the most pleasant perk when comparing a bank transfer and a Bitcoin transfer.": "**첫째**, 데이터의 불변성. 물론, 전자 현금의 관점에서 이 속성은 상당��� 장점과 중요성을 가지고 있습니다. 거래를 보내거나 비트코인을 받은 후, 한 두 개의 블록 후에 블록체인에서 데이터의 불변성을 점차 느끼기 시작합니다. 처음 15분 동안, 블록체인 탐색기를 사용하여 거래가 해결되는 것을 관찰할 수 있습니다. 이미 네트워크에서 보이지만 최종화되지 않았으므로 이 비트코인은 아직 당신의 계정에 없습니다. 그러나 몇 개의 블록 후에는 이 자금이 당신의 계정에서 사라지지 않을 것이라는 확신이 생깁니다. 시간이 지남에 따라 값이 당신의 계정에서 어떤 식으로든 덮어씌워질 가능성은 거의 없어져 거의 제로로 줄어듭니다. 이것이 바로 데이터 불변성의 속성입니다. 정보를 수령자와 공유하고, 그들에게 블록체인 탐색기 링크를 보내고, 은행에서 특정 날짜와 시간에 지불을 보냈다는 것을 증명하는 어떤 종이나 문서를 얻을 필요가 없을 때 얼마나 멋진지 - 이것은 은행 송금과 비트코인 송금을 비교할 때 아주 도움이 되는 두 번째 비트코인의 장점입니다.",
  "**Secondly**, transparency of transactions. There is practically no fear when using Bitcoin that you will find yourself in a region of the world or connected to an internet provider through which you cannot perform operations with the Bitcoin network. There are practically no options other than locking you in a dark room without internet access so that you cannot use the Bitcoin network.": "**둘째**, 거래의 투명성. 비트코인을 사용할 때 세계의 어느 지역에 있든 인터넷 공급업체를 통해 연결되든, 비트코인 네트워크와�� 작업을 수행할 수 없는 상황에 놓일 것을 두려워할 필요가 거의 없습니다. 당신을 인터넷 접속이 불가능한 어두운 방에 가두어 놓는 것 외에는 비트코인 네트워크를 사용할 수 없도록 하는 옵션이 거의 없습니다.",
  "These three properties are, of course, very important. Now, in order to understand the question \"What is at the heart of the world computer,\" we will need to step back from them, abstract ourselves, and make a small leap of faith, a jump, approximately, 100 years back to the 1930s.": "이 세 가지 속성은 물론 매우 중요합니다. 이제 \"세계 컴퓨터의 핵심은 무엇인가\"라는 질문을 이해하기 위해 그들로부터 물러나서 우리 자신을 추상화하고, 약간의 믿음의 도약, 약간의 점프를 해야 할 것입니다. 대략 1930년대로 100년 정도 거슬러 올라가야 합니다.",
  "In 1936, Alan Turing made a proposal to the scientific community to solve the formalization problem and, in fact, a more qualitative description of such a concept as an algorithm. Interestingly, from Alan Turing's proposal, the architecture and development of all computer science in the future emerged, but he in no way pursued the idea of creating a personal computer, and he knew nothing about data centers or clouds. His task was to provide a way to define an algorithm in the context of the tasks faced by mathematicians. It's a fascinating picture over the span of a century that the achievement of computer science turns out to be a by-product of a rather mundane problem among mathematicians.": "1936년, 앨런 튜링은 형식화 문제를 해결하고 사실 알고리즘이라는 개념을 더 질적으로 설명하기 위해 과학 커뮤니티에 제안했습니다. 흥미로운 점은 앨런 튜링의 제안으로 인해 미래의 모든 컴퓨터 과학의 구조와 발전이 나타났지만, 그는 개인용 컴퓨터를 만드는 아이디어를 추구하지 않았으며 데이터 센터나 클라우드에 대해 전혀 알지 못했습니다. 그의 임무는 수학자들이 직면한 과제의 맥락에서 알고리즘을 정의하는 방법을 제공하는 것이었습니다. 수학자들 사이에서 다소 일상적인 문제의 부산물로 컴퓨터 과학의 성취가 나타나는 세기를 거슬러 올라가는 것은 매우 흥미로운 모습입니다.",
  "Let's delve into what Alan Turing proposed, without delving too deeply into algorithm theory and the purpose for which he suggested it. Alan Turing proposed the Turing machine, which represents an infinite tape (we can call it memory cells to make it easier), traversed by a reading and writing head. This head, positioned over a certain cell, can read data, apply some simple operations to them, and write new values.": "앨런 튜링이 제안한 것에 대해 깊이 파고들지 않고도 알고리즘 이론과 그가 제안한 목적에 대해 파헤쳐 봅시다. 앨런 튜링은 튜링 기계를 제안했는데, 이는 무한한 테이프(우리는 이를 기억 셀이라고 부를 수 있습니다)를 통해 통과하는 읽기 및 쓰기 헤드를 나타냅니다. 이 헤드는 특정 셀 위에 위치하여 데이터를 읽고, 그에게 일부 간단한 작업을 적용하고, 새로운 값을 쓸 수 있습니다.",
  "Today, when you hear phrases like this, it might seem to you: \"Well, yes, it's a hard drive, a computer, or something like that.\" That's absolutely correct. This description gave rise to the first computer architecture. However, the main task of the Turing machine was to provide a means of representing a system or entity capable of performing any formalized computations. One can imagine a box or room, even filled with lamps, into which you insert your punch card, card, or transmit a Bluetooth signal, and the machine starts working, performing simple operations that ultimately solve your problem. Thus, the Turing machine is a universal computational mechanism that primarily solves the universal and essential task of providing a mechanism through which any simple computation or, more accurately, any formalized computation can be performed—computations that can be decomposed into the language of mathematics": "오늘날 이와 같은 구절을 들으면 아마도 \"음, 그래, 하드 드라이브, 컴퓨터 또는 그런 것이겠지\"라고 생각할 수 있습니다. 그것이 완전히 맞습니다. 이 설명은 첫 번째 컴퓨터 아키텍처를 탄생시켰습니다. 그러나 튜링 기계의 주요 임무는 어떤 형식화된 계산을 수행할 수 있는 시스템이나 개체를 나타내는 수단을 제공하는 것이었습니다. 단순한 작업을 수행하는 기계가 최종적으로 문제를 해결하는 튜링 기계는 수학의 언어로 분해할 수 있는 어떤 단순한 계산 또는 보다 정확히 말하면 어떤 형식화된 계산을 수행할 수 있는 메커니즘을 제공하는 본질적인 과제를 주로 해결하는 범용 계산 메커니즘이었습니다.",
  "In essence, the task of the last 100 years, after finding some solution in the field of mathematics, was precisely to give it a physical form, to find the set of transistors that could be placed on a board, learn how to solder them all, reduce the processes of the computing processor, and so on. No wonder that the theory from 1936 finds application in 2014 for the ideas of the world computer. These 100 years were occupied, in general, in another area—the field of physically implementing this computer.": "본질적으로, 지난 100년 동안의 작업은 수학 분야에서 어떤 해결책을 찾은 후에 정확히 물리적 형태를 부여하고, 보드에 배치할 수 있는 트랜지스터 세트를 찾고, 모두 납땜하는 방법을 배우며, 컴퓨팅 프로세서의 프로세스를 줄이는 등이었습니다. 1936년의 이론이 2014년에 세계 컴퓨터의 아이디어에 적용되는 것이 놀라운 일이 아닙니다. 이 100년 동안은 일반적으로 다른 분야—이 컴퓨터를 물리적으로 구현하는 분야에서 점령되었습니다.",
  "When the planet became saturated, and we had personal computers, computational machines even inside smart devices, and when data centers started growing on the planet, the question shifted from the hardware solution to how the computational machine might look not at the physical or mathematically abstract level but at some non-physical, perhaps metaphysical, level relative to the entire planet. However, the foundation remains the same: the state transition function and nothing else.": "행성이 포화되고 개인용 컴퓨터, 스마트 기기 내부에서 계산 기계가 작동하기 시작하고 데이터 센터가 행성 전체에 걸쳐 성장하기 시작할 때, 문제는 하드웨어 솔루션에서 계산 기계가 물리적 또는 수학적으로 추상적인 수준이 아닌 어떤 비물리적, 아마도 형이상적인 수준에서 전체 행성에 상대적으로 어떻게 보일지로 이동했습니다. 그러나 기초는 변함없이 유지됩니다: 상태 전이 함수와 그 외의 것은 없습니다.",
  "As an addition to what has been said, so that we don't only dwell on the theory of 1936 and don't just break the shackles of Bitcoin maximalists, open the Ethereum white paper. There you will find the crucial phrase \"Turing complete machine\"—this is the main definition of Ethereum. A Turing complete machine means that Ethereum can handle any simple operations described in a formal language, operations that are possible. This is not some set of operations that Ethereum can provide as a calculator or a sophisticated calculator for scientists. Instead, it is an abstraction inside which it is possible to load any possible variations, manipulations with variables, constants, additions, calculations with any states, and so on. You won't find anything different from what Turing proposed in the 1930s in the Ethereum concept. You will find an engineering implementation of how to do it. If we move on and open the Polkadot wiki, it's a bit more challenging to find. For this, you should use the search, enter \"State transition,\" and in the search results, find several mentions that Polkadot guarantees nothing else but the state transition. Neither the storage of data in the Polkadot blockchain nor any additional services—only the purest change of state caused by incoming transactions and processed by Polkadot validators. Now, let's try to delve more into this.": "이에 덧붙여 1936년 이론에만 집중하지 않고 비트코인 맥시멀리스트의 족쇄를 풀기 위해 이더리움 화이���페이퍼를 열어보십시오. 거기에서 \"튜링 완전 기계\"라는 중요한 구절을 찾을 수 있습니다—이것이 이더리움의 주요 정의입니다. 튜링 완전 기계란 이더리움이 형식 언어로 설명된 어떤 간단한 작업도 처리할 수 있다는 것을 의미합니다. 이는 이더리움이 과학자들을 위한 계산기나 정교한 계산기로 제공할 수 있는 일련의 작업이 아닙니다. 대신, 이는 어떤 가능한 변형, 변수, 상수, 추가, 어떤 상태와의 계산 등을 로드할 수 있는 추상화입니다. 1930년대에 튜링이 제안한 것과 다른 것은 이더리움 개념에서 찾을 수 없습니다. 이것은 어떻게 하는지에 대한 공학적 구현을 찾을 수 있습니다. 계속해서 폴카닷 위키를 열어보면 조금 더 어려울 수 있습니다. 이를 위해 검색을 사용하고 \"상태 전이\"를 입력하고 검색 결과에서 폴카닷이 상태 전이 외에는 아무것도 보장하지 않는다는 여러 언급을 찾아보십시오. 폴카닷 블록체인에 데이터를 저장하거나 추가 서비스를 제공하지 않습니다—오직 들어오는 트랜잭션에 의해 유발된 상태 변경만을 순수하게 처리합니다. 이제 이에 대해 더 깊이 파고들어보려고 해봅시다.",
  "Now, let's add a bit to this linear diagram to move from the theory of the 1930s to today's realities, where we describe the abstract picture of the world computer. To do this, let's consider an example with Alice and Bob. Alice, being in the office, wants to start Bob's home vacuum robot for cleaning. If we look at today's concepts of how the link between Alice's mobile application and the robot vacuum at home is implemented, you will see roughly the following picture: Alice's mobile application generates a transaction in some cloud where calculations take place, and the output of these calculations is the output values that effectively turn into a command to start the vacuum robot. It would be useful for us, from the field of robotics and Robonomics as concepts in the world of web3, to understand that in the cloud, there is a digital twin of this robot, and its state is changed. We can, in general, not go that far and stop at the fact that Alice sends a transaction to the cloud, and the cloud, having performed all the necessary calculations and manipulations, generates a command to start Bob's vacuum robot.": "지금, 1930년대 이론에서 오늘날의 현실로 이동하기 위해이 선형 다이어그램에 약간 추가 해 보겠습니다. 여기서 우리는 세계 컴퓨터의 추상적인 그림을 설명하는 곳입니다. 이를 위해 앨리스와 밥의 예를 고려해 보겠습니다. 사무실에 있는 앨리스는 청소를 위해 밥의 집 진공 로봇을 시작하려고 합니다. 오늘날의 앨리스의 모바일 애플리케이션과 집의 로봇 진공 사이의 링크가 어떻게 구현되었는지 살펴보면 대략 다음과 같은 그림을 볼 수 있습니다: 앨리스의 모바일 애플리케이션은 계산이 이루어지는 어딘가의 클라우드에서 트랜잭션을 생성하고 이러한 계산의 출력은 효과적으로 진공 로봇을 시작하는 명령으로 변환됩니다. 우리에게는 웹3의 세계에서 개념으로서의 로봇 과 로보노믹스로부터 이 로봇의 디지털 트윈이 클라우드에 있고 그 상태가 변경된다는 것을 이해하는 것이 유용할 것입니다. 우리는 일반적으로 그렇게 멀리 가지 않고 앨리스가 클라우드로 트랜잭션을 보내고 클라우드가 모든 필요한 계산과 조작을 수행한 후 밥의 진공 로봇을 시작하는 명령을 생성한다는 사실에서 멈출 수 있습니다.",
  "In this scheme today, there are several main questions: if you were interacting with a physical computer in front of you or were in a room with the vacuum robot, you would approach, press a physical button, and set it in motion. What changes when instead of arrows, there is not a manual drive but a communication layer, the internet? A multitude of questions arises about how we can safely connect Alice and this cloud, how we can be sure that Alice has access to this cloud. The question of the communication network arises—how we can protect Alice from someone else addressing her vacuum robot, requesting, for example, to make a video of her entire apartment instead of cleaning, and a similar aspect arises: why would the vacuum robot listen to this cloud with such honor and integrity? Why would the robot fully trust this cloud?": "오늘 이 계획에서는 몇 가지 주요 질문이 있습니다: 당신이 당신 앞에 있는 물리적 컴퓨터와 상호 작용하고 있었거나 진공 로봇이 있는 방에 있었다면, 당신은 접근하고 물리적 버튼을 누르고 그것을 가동시킬 것입니다. 화살표 대신 인터넷이 있는 경우 어떻게 변화하는가? 우리는 어떻게 앨리스와 이 클라우드를 안전하게 연결할 수 있는지, 앨리스가 이 클라우드에 액세스할 수 있는지 어떻게 확신할 수 있는지에 대한 다양한 질문이 제기됩니다. 통신 네트워크에 대한 질문이 제기됩니다 - 어떻게 다른 사람이 그녀의 진공 로봇에 접근하려고 할 때 앨리스를 보호할 수 있을까요? 예를 들어, 청소 대신 전체 아파트의 비디오를 만들도록 요청하고 진공 로봇이 이 클라우드를 왜 이렇게 존경하고 성실하게 듣는지에 대한 유사한 측면이 제기됩니다. 로봇이 왜 이 클라우드를 완전히 신뢰할까요?",
  "Today's approach with the architecture of cloud solutions that connect your mobile phone, or rather, the application on your mobile phone, and some technology on the other side, smart devices, is based on the significant achievements in building physical computers. Computers in data centers today are something extraordinary—the level of technical processes is simply amazing. However, from the perspective of communication technologies, when you already have some experience working with internet applications, it seems that somewhere there, at the level of a technical school or college, or maybe not right next to how developers, architects of Intel processors are solving their tasks now. Almost all questions about connecting Alice to Bob boil down solely to outputting a specific access certificate on a specific IP address from both sides, linking them together, and the cloud will own and do anything. The most important thing in this scheme is to do anything, meaning to perform state transitions or operations that occur without any guarantees that for Alice, for Bob, these will be executed according to the same logic. No one can say anything about how the cloud is arranged. It is a black box where computations are not formalized, and neither Alice nor Bob knows how the computation is performed.": "오늘의 클라우드 솔루션 아키텍처 접근 ���식은 모바일 폰을 연결하는 것이며, 다시 말해, 모바일 폰의 애플리케이션과 다른 쪽에있는 일부 기술, 스마트 기기를 연결하는 것은 물리적 컴퓨터를 구축하는 중요한 성취에 기반합니다. 오늘 데이터 센터의 컴퓨터는 놀라운 것입니다 - 기술적 프로세스 수준은 간단히 놀랍습니다. 그러나 통신 기술의 관점에서 이미 인터넷 애플리케이션을 사용해 본 경험이 있는 경우, 기술 학교나 대학, 또는 아마도 인텔 프로세서 개발자, 아키텍트가 지금 자신의 작업을 어떻게 해결하고 있는지 바로 옆에 있지 않을 수도 있습니다. 앨리스를 밥에 연결하는 모든 질문은 단순히 양쪽에서 특정 IP 주소에 대한 특정 액세스 인증서를 출력하고 연결하여 클라우드가 모든 것을 소유하고 수행할 것이라는 것으로 귀결됩니다. 이 계획에서 가장 중요한 것은 무엇이든 수행하는 것입니다. 즉, 앨리스, 밥에게 이것이 동일한 논리에 따라 실행될 것이라는 보장이 없는 상태 전이나 작업을 수행하는 것입니다. 아무도 클라우드가 어떻게 구성되어 있는지에 대해 어떤 말도 할 수 없습니다. 계산이 형식화되지 않는 블랙 박스이며, 앨리스나 밥이 계산이 어떻게 수행되는지 알지 못합니다.",
  "The place where you must fully trust—relying on the reputation of the company that owns these data centers, and you must completely trust the network access providers who issue a certificate and verify the security of your connection. In fact, if we talk about the boom of internet applications, this is a huge problem. The problem is that there are actually some citadels located in specific jurisdictions that operate on a relatively simple technology stack to connect you as easily as possible to the cloud, which represents a black box. Dissatisfaction with this approach actually arouses interest in the world computer because it will arrange things a bit differently. And how? Let's try to supplement the scheme we drew with blue color right now.": "완전히 신뢰해야 하는 곳은 이러한 데이터 센터를 소유한 회사의 평판에 의존해야 하며, 인증서를 발급하고 연결의 보안을 확인하는 네트워크 액세스 제공자를 완전히 신뢰해야 합니다. 사실, 인터넷 애플리케이션의 붐에 대해 이야기한다면, 이것은 큰 문제입니다. 문제는 실제로 특정 관할 지역에 위치한 몇몇 요새가 클라우드에 가능한 쉽게 연결할 수 있도록 상대적으로 간단한 기술 스택에서 작동한다는 것입니다. 이 접근 방식에 대한 불만은 사실 세계 컴퓨터에 대한 관심을 불러일으키며, 이것은 조금 다르게 일을 처리할 것입니다. 그리고 어떻게? 우리가 지금 그린 계획을 파란색으로 보완해 보겠습니다.",
  "So, to supplement our linear graph, our linear diagram from both sides, let's take a look at the discoveries that have significance in computer science and that are directly or indirectly related to achievements from the world of web3.": "그래서 우리의 선형 그래프, 양쪽에서의 선형 다이어그램을 보완하기 위해 컴퓨터 과학에서 중요한 의미를 가지는 발견을 살펴보겠습니다.",
  "Let's start with Leslie Lamport in 1976. Those who attended my presentations, lectures from 2015-2020, probably remember how often I liked to mention that before the invention of Bitcoin, problems related to creating a decentralized network were well described by Leslie Lamport in 1976 in the Byzantine Generals problem. The solution to the Byzantine Generals problem is at the core of Tendermint PBFT algorithms and all synchronous algorithms used from Telegram Open Network to Tendermint, to Cosmos, and other blockchain projects that, accordingly, followed the path of Byzantine Generals.": "1976년 레슬리 램포트부터 시작해 보겠습니다. 2015년부터 2020년까지 제 발표, 강의에 참석한 사람들은 아마도 비잔틴 장군 문제에 대해 레슬리 램포트가 1976년에 잘 기술한 분산 네트워크 생성과 관련된 문제를 얼마나 자주 언급했는지 ���억할 것입니다. 비잔틴 장군 문제의 해결책은 텐더민트 PBFT 알고리즘의 핵심이며, 텔레그램 오픈 네트워크부터 텐더민트, 코스모스 및 기타 블록체인 프로젝트에 이르기까지 사용되는 모든 동기화 알고리즘에 사용됩니다. 이러한 경로를 따라간 프로젝트들은 모두 비잔틴 장군의 길을 따랐습니다.",
  "The second interesting achievement in internet technologies is torrent trackers. We don't have any specific, already erased, cloud or a black box that stores files. Still, users worldwide, by exchanging torrent files, can download exactly the file they were looking for, and this works without data substitution. No one uploads any viruses to you by replacing the file. There might sometimes be a virus embedded in the file, but the idea of receiving a link to download and actually downloading something other than what you were offered to download using torrent technology is impossible. Similar processes exist in the IPFS network, a hash-oriented storage - a way of connecting various participants with trust in the information you convey without using a black box, precisely.": "인터넷 기술에서 두 번째 흥미로운 성취는 토렌트 트래커입니다. 우리는 특정한 이미 삭제된 클라우드나 파일을 저장하는 블랙 박스를 가지고 있지 않습니다. 그럼에도 불구하고 전 세계의 사용자들은 토렌트 파일을 교환함으로써 정확히 원하는 파일을 다운로드할 수 있으며, 이는 데이터 치환 없이 작동합니다. 누구도 파일을 교체하여 바이러스를 업로드하지 않습니다. 파일에 내장된 바이러스가 가끔 있을 수 있지만, 토렌트 기술을 사용하여 다운로드할 링크를 받고 실제로 제공된 것과 다른 것을 다운로드하는 것은 불가능합니다. IPFS 네트워크에도 유사한 프로세스가 존재하며, 해시 중심 저장 - 블랙 박스를 사용하지 않고 다양한 참가자들을 신뢰할 수 있는 정보로 연결하는 방법입니다.",
  "And of course, Bitcoin. Bitcoin, as a more collective example, I'm sure Satoshi Nakamoto was well aware of Leslie Lamport's solution to the Byzantine Generals problem and, of course, observed how the idea of torrent trackers was developing. If we don't emphasize the properties that the Bitcoin blockchain obtained, such as immutability, transparency of transactions, and, to some extent, censorship resistance, then Bitcoin is an internet service that performs state transition, some changes in state based on transactions without a central node. It is an example of a collective construction of a global network in which there is a constantly functioning state transition function that we can trust, and to ensure trust, neither jurisdictions nor specific IP addresses nor the most primitive technologies used and still used today in building cloud services are used. The collective image of Bitcoin allowed overlaying the general concept from the 1930s of a Turing-complete machine on the existence of a universal abstract function for everything.": "물론, 비트코인입니다. 비트코인은 더 많은 집단적인 예로, 나는 확실히 사토시 나카모토가 레슬리 램포트의 비잔틴 장군 문제에 대한 해결책을 잘 알고 있었고, 물론 토렌트 트래커의 아이디어가 어떻게 발전하는지도 관찰했을 것입니다. 비트코인 블록체인이 획���한 불변성, 거래의 투명성 및 어느 정도의 검열 저항과 같은 속성을 강조하지 않는다면, 비트코인은 중앙 노드 없이 거래에 기반한 상태 변화를 수행하는 인터넷 서비스입니다. 우리가 신뢰할 수 있는 지속적으로 작동하는 상태 전환 기능이 있는 글로벌 네트워크의 집단적인 구축의 예시이며, 신뢰를 보장하기 위해 국가 법률, 특정 IP 주소 또는 클라우드 서비스 구축에 사용되는 가장 원시적인 기술들도 사용되지 않습니다. 비트코인의 집단적인 이미지는 1930년대의 튜링 완전 기계 개념을 존재하는 모든 것에 대한 범용 추상 함수와 겹쳐 놓을 수 있게 했습니다.",
  "So, what do we need to add to this scheme to envision a global computer? From the bottom, we provide consensus validators or, in general, validators. It can be said that the \"Data availability layer\" is probably a phrase many have heard around Ethereum this year, and it has become an advantage of Bitcoin as well. However, in the organization scheme of the global computer, this is one piece of the puzzle and, as I mentioned, it complements the main function that lies at the heart of the global computer—the function of universal state transition. Going back to the very beginning, the analogy of the heart in the human body is interesting here. It's not a thinking thing, indeed. Yes, it doesn't generate, you could say, the brain is much more important. Still, life is impossible without the heart. It simply pumps blood. Similarly, at the core of the global computer, all transactions are pumped through the state transition function, resulting in outputs. But to organize this in a distributed internet network without the need to trust some citadel, we need to supplement the picture with two components.": "그래서, 우리가 전역 컴퓨터를 상상하기 위해 이 계획에 무엇을 추가해야 할까요? 바닥에서부터, 우리는 합의 유효성 검사자 또는 일반적으로 유효성 검사자를 제공합니다. '데이터 가용성 계층'이라는 표현은 올해 이더리움 주변에서 많이 들어본 말이며, 이는 비트코인의 장점이 되었습니다. 그러나 전역 컴퓨터의 조직 체계에서 이것은 퍼즐의 한 조각이며, 내가 언급한 대로, 이는 전역 컴퓨터의 핵심에 있는 범용 상태 전환 기능을 보완합니다. 매우 처음으로 돌아가서, 인간 몸의 심장에 대한 비유는 여기서 흥미롭습니다. 실제로 생각하는 것이 아닙니다. 네, 생성하지 않습니다, 뇌가 훨씬 중요하다고 말할 수 있습니다. 그래도 심장 없이는 삶이 불가능합니다. 그냥 혈액을 펌핑하는 것뿐입니다. 마찬가지로, 전역 컴퓨터의 핵심에는 모든 거래가 상태 전환 기능을 통해 펌핑되어 결과를 출력합니다. 그러나 어떤 요새를 신뢰할 필요 없이 분산된 인터넷 네트워크에서 이를 조직하기 위해 우리는 두 가지 구성 요소로 그림을 보충해야 합니다.",
  "The first component is a set of computers or nodes that are ready to execute the state transition. When you send transactions, they don't just go here; they go to the validators. Validators perform computations, recalling what I've already mentioned in this ongoing conversation. They take your transaction, retrieve information from the blockchain about how to process that transaction, apply that processing, and then coordinate with other validators the fact that they correctly executed the state transition. The core of the global computer, in terms of protection against situations where Bob, the vacuum cleaner robot, receives a correct command from Alice in the office, is not based on trust but on cross-verification by a multitude of network participants based on available information from the blockchain. Not only from the blockchain, by the way. It's complex, and we won't delve into it right now, but essentially, a multitude of validators take turns watching and have incentives, some internal incentives within the protocol, to prevent the universal and capable-of-calculating-anything machine from executing this operation incorrectly. A validator effectively processes transactions that come into the global computer, and other validators help prevent situations where one of the validators performed an incorrect calculation. The better the consensus algorithms of the validators, the better protection we have for the state transition function or, in other words, the heart of our global computer.": "첫 번째 구성 요소는 상태 전이를 실행할 준비가 된 컴퓨터 또는 노드 집합입니다. 거래를 보낼 때, 그냥 여기로 가는 것이 아니라 유효성 검사자에게 가게 됩니다. 유효성 검사자는 계산을 수행하며, 계속되는 대화에서 이미 언급한 것을 상기시킵니다. 당신의 거래를 가져와서 그 거래를 처리하는 방법에 대한 블록체인에서의 정보를 검색하고, 그 처리를 적용하고, 그런 다음 다른 유효성 검사자들과 협력하여 상태 전이를 올바르게 실행했다는 사실을 확인합니다. 글로벌 컴퓨터의 핵심은 신뢰가 아닌 블록체인의 정보를 기반으로 다수의 네트워크 참가자들에 의한 상호 검증에 기초합니다. 그리고 블록체인만이 아닙니다. 복잡하며 지금은 자세히 다루지 않겠지만, 본질적으로 다수의 유효성 검사자가 번갈아가며 감시하고, 프로토콜 내에서 일부 내부 인센티브를 가지고 있어서 모든 것을 계산할 수 있는 기계가 이 작업을 잘못 실행하는 것을 방지합니다. 유효성 검사자는 글로벌 컴퓨터로 들어오는 거래를 효과적으로 처리하며, 다른 유효성 검사자들은 ��못된 계산을 한 유효성 검사자가 발생하는 상황을 방지합니다. 유효성 검사자의 합의 알고리즘이 더 좋을수록 상태 전이 기능 또는 다른 말로 글로벌 컴퓨터의 핵심에 대한 보호가 더 좋아집니다.",
  "The second part of this scheme is the data availability service—what we've always called the database in Bitcoin or Ethereum. In fact, we'll have to abandon that concept because there's a fundamental change in the architecture of all projects, and for those specifically targeting the global computer, this change is most crucial. For a simple present-day example: there are various implementations of Layer 2 networks on top of Ethereum—such as Arbitrum, Optimism, and others. If you start looking into their main differences and how they operate, you'll find that, in some cases, an L2 network in Ethereum sends a larger amount of data, solely from the first-layer blockchain, i.e., from the Ethereum blockchain. All the necessary puzzle pieces to confirm that the computation on the L2 layer was correct can be found in the first-layer Ethereum blockchain. On the other hand, other approaches suggest that beyond the first layer of Ethereum, something else is stored that needs to be found to prove the correctness of transactions. So, right now, before our eyes, there is again a question of improvement, but specifically of such an architecture where transactions go on the left, in the middle, we have the heart in the form of the state transition function, validators, and their consensus allows for the correct execution of this state transition. But there is also a question of data availability, which is necessary to ensure both cross-verification and, essentially, the existence of the service itself. Some approaches and patterns for creating L2 on top of Ethereum today ask the question: \"What if a certain L2 layer loses the data it doesn't store within the main Ethereum blockchain?\"": "이 계획의 두 번째 부분은 데이터 가용성 서비스입니다. 우리가 항상 비트코인이나 이더리움에서 데이터베이스라고 불렀던 것입니다. 사실, 모든 프로젝트의 아키텍처에 근본적인 변화가 있기 때문에 그 개념을 포기해야 할 것입니다. 특히 글로벌 컴퓨터를 대상으로 하는 경우, 이 변화가 가장 중요합니다. 현재의 간단한 예로는 이더리움 위에 Layer 2 네트워크의 다양한 구현이 있습니다. - 예를 들어 Arbitrum, Optimism 등이 있습니다. 그들의 주요 차이점과 작동 방식을 살펴보면, 경우에 따라 이더리움의 L2 네트워크가 이더리움 블록체인에서만 더 많은 양의 데이터를 보내는 것을 발견할 수 있습니다. L2 레이어에서의 계산이 올바른지 확인하기 위한 모든 필요한 퍼즐 조각은 첫 번째 레이어 이더리움 블록체인에서 찾을 수 있습니다. 반면에 다른 접근 방식은 이더리움의 첫 번째 레이어를 넘어서서 거래의 정확성을 증명하기 위해 찾아야 할 다른 것이 저장되어 있다고 제안합니다. 따라서 지금 우리 눈앞에는 다시 개선의 문제가 있지만, 특히 거래가 왼쪽으로 진행되는 이러한 아키텍처의 경우, 중간에는 상태 전이 함수, 검증자, 그들의 합의가 이 상태 전이의 올바른 실행을 가능하게 합니다. 그러나 데이터 가용성의 문제도 있습니다. 이는 교차 확인과 본질적으로 서비스 자체의 존재를 보장하기 위해 필요합니다. 오늘날 이더리움 위에 L2를 만드는 몇 가지 접근 방식과 패턴은 다음과 같은 질문을 던집니다: \"만약 특정 L2 레이어가 주요 이더리움 블록체인 내에 저장하지 않은 데이터를 잃어버린다면 어떻게 될까?\"",
  "Let's complement this picture with how Polkadot is structured. Polkadot has two consensus mechanisms: the \"babe\" consensus, responsible for the parachain-level consensus and is fast, and the \"grandpa\" consensus, which is slower and verifies everything afterward. So, if you delve into the wiki article titled \"The Path of a Block in the Polkadot Network,\" you will encounter interesting abbreviations. After achieving the \"babe\" consensus at the parachain level, the \"grandpa\" consensus introduces the concept of \"proof of validity and data availability.\" Going deeper, you'll find the term \"chunk\" of redundant pieces of information, inspired by CD RW technologies from the 90s and 2000s. This addresses the question of how to preserve information when absolute trust in a specific entity in the network is not feasible. The concept of \"chunk\" of redundant information is one of these patterns.": "이 그림을 폴카닷이 어떻게 구성되어 있는지로 보완해 봅시다. 폴카닷에는 두 가지 합의 메커니즘이 있습니다: 파라체인 수준의 합의를 담당하는 \"babe\" 합의와 빠르며, 모든 것을 검증하는 \"grandpa\" 합의가 있습니다. 따라서 폴카닷 네트워크에서 블록의 경로라는 위키 문서를 깊이 파고들면 흥미로운 약어를 만날 것입니다. 파라체인 수준에서 \"babe\" 합의를 달성한 후, \"grandpa\" 합의는 \"유효성 증명 및 데이터 가용성\" 개념을 소개합니다. 더 깊이 들어가면, 90년대와 2000년대의 CD RW 기술에서 영감을 받은 중복 정보의 \"청크\" 용어를 찾을 수 있습니다. 네트워크에서 특정 엔티티에 대한 절대적인 신뢰가 불가능할 때 정보를 보존하는 방법에 대한 질문을 다룹니다. 중복 정보의 \"청크\" 개념은 이러한 패턴 중 하나입니다.",
  "Summing up, at the core lies an abstract function that enables any computation and was described by Alan Turing in the 1930s. The personal computer, essentially a side effect of a mathematical problem, emerged from Turing's work. The technologies first applied in Bitcoin, such as consensus that allows the network to exist without a specific data center or entity responsible for data correctness, form a functioning mechanism. It goes beyond providing a specific service for electronic cash transfers; it allows us to audit and control any computation in the network. Additionally, we face the challenge of ensuring data availability, as it's not the primary concern of the world computer. The world computer's task lies at its core, executing computation, managing state transitions, and performing calculations, while the data in this scheme serves as a puzzle piece that is more necessary to support the lower part. Thus, this overall scheme can be seen as an abstract and generalized illustration of the world computer's structure, where the state transition function is at its core.": "요약하면, 핵심에는 1930년대 앨런 터링에 의해 설명된 어떤 계산도 가능하게 하는 추상 함수가 있습니다. 개인 컴퓨터는 본질적으로 수학적 문제의 부작용으로 나타났습니다. 비트코인에 처음 적용된 합의와 같은 기술은 특정 데이터 센터나 데이터 정확성에 책임을 지는 특정 엔티티 없이 네트워크가 존재할 수 있도록 하는 메커니즘을 형성합니다. 이는 특정 전자 현금 이체 서비스를 제공하는 것을 넘어서 네트워크에서 어떤 계산이든 감사하고 제어할 수 있게 합니다. 또한, 데이터 가용성을 보장하는 것이 도전이 되는데, 이는 세계 컴퓨터의 주요 관심사가 아닙니다. 세계 컴퓨터의 임무는 계산을 실행하고 상태 전이를 관리하며 계산을 수행하는 것이며, 이 계획에서 데이터는 하단을 지원하는 더 필수적인 퍼즐 조각으로 작용합니다. 따라서 이 전체 계획은 상태 전이 함수가 핵심인 세계 컴퓨터 구조의 추상적이고 일반화된 표현으로 볼 수 있습니다.",
  "Part 4: The Path of a New Block of Information in the World Computer": "제4부: 세계 컴퓨터에서 새로운 정보 블록의 경로",
  "The fourth and final part of our lecture is \"The World Computer in Your Home.\" After this, I will begin recording screencasts for the practical part of the sessions.": "저희 강의의 네 번째이자 마지막 부분은 \"당신의 집에 있는 세계 컴퓨터\"입니다. 이후에 저는 세션의 실제 부분을 위해 스크린캐스트 녹화를 시작하겠습니다.",
  "Now we will try to summarize almost all the theory we have covered so far in terms of one process. The process that describes the path of an information block in the world computer. Let's start again by returning to the theme of web3 and the concept of blockchain. The phrase \"block\" or \"information block\" can be considered identical when stepping away from the last 10 years and taking a more general theory, as explored in the previous parts of the lectures. The concept of a \"block of information\" aligns with web3, but not necessarily with blockchain. Even without any crypto projects, we need to understand that when forming the theory of the world computer without referencing the formation of information blocks, it's currently challenging to envision other models. So, we will consider the path of an information block throughout the entire world computer, not because it is blockchain, but because, for now, there are no other ways to conceptualize the existence of the world computer other than by processing information in specific portions.": "이제 우리는 거의 모든 이론을 하나의 과정으로 요약해보려 합니다. 세계 컴퓨터에서 정보 블록의 경로를 설명하는 과정입니다. 웹3의 주제와 블록체인의 개념으로 돌아가 시작해봅시다. \"블록\" 또는 \"정보 블록\"이라는 구절은 마지막 10년을 벗어나 더 일반적인 이론으로 생각할 때, 이전 강의의 이전 부분에서 탐구한 것과 일치합니다. \"정보 블록\"이라는 개념은 웹3와 일치하지만 블록체인과는 일치하지 않습니다. 암호화 프로젝트가 없더라도, 정보 블록의 형성을 참조하지 않고 세계 컴퓨터의 이론을 형성할 때, 다른 모델을 상상하기가 현재는 어렵습니다. 그래서 우리는 세계 컴퓨터 전체를 통해 정보 블록의 경로를 고려할 것입니다. 이는 블록체인 때문이 아니라, 현재는 정보를 특정 부분에서 처리함으로써 세계 컴퓨터의 ��재를 개념화하는 다른 방법이 없기 때문입니다.",
  "Block of information = block in web3, but without blockchain and without any crypto project influence. We must currently consider the formation of information blocks when discussing the theory of the world computer. Now, let's move on to the first point. I tried to find close analogies from everyday life to help illustrate the path of an information block in the world computer. The analogy I've chosen is the movement of a bus on a route. Our first meeting point is the bus station.": "정보 블록 = 웹3의 블록, 그러나 블록체인과 암호화 프로젝트의 영향이 없습니다. 세계 컴퓨터의 이론을 논의할 때 정보 블록의 형성을 고려해야 합니다. 이제 첫 번째로 넘어가 봅시다. 저는 세계 컴퓨터에서 정보 블록의 경로를 설명하는 데 도움이 될 수 있는 일상 생활에서의 유사성을 찾아보려고 노력했습니다. 저는 버스가 경로를 이동하는 것을 선택했습니다. 우리의 첫 만남 지점은 버스 정류장입니다.",
  "I marked transactions in pink as small dots. Let's imagine a typical bus stop where people gather, waiting for a bus that operates on a schedule. If we don't consider the hustle and bustle of large cities, where buses are always late, everyone in the world generally knows that the train from village A to village B always arrives around 7:15 am. Transactions that users want to send to the world computer gather at a certain bus stop and wait for the bus to arrive.": "저는 거래를 작은 점으로 핑크색으로 표시했습니다. 일정에 따라 운행하는 버스를 기다리는 사람들이 모이는 전형적인 버스 정류장을 상상해봅시다. 대도시의 북적거림을 고려하지 않는다면, 세계의 모든 사람들은 일반적으로 마을 A에서 마을 B로 가는 기차가 항상 오전 7:15쯤 도착한다는 것을 알고 있습니다. 사용자가 세계 컴퓨터로 보내려는 거래는 특정 버스 정류장에서 모여 버스가 도착할 때까지 기다립니다.",
  "This is how our block is formed. Imagine: the bus arrives, and each person starts boarding one by one, taking their seats. The bus then follows its route. In our case, the block of information overcomes the first frontier. Our transactions, in some form, have settled into the bus and overcome the initial barrier. I will be using terminology primarily from Polkadot, and the third part should have better explained the concept of the world computer in the comparison between Ethereum and Polkadot. My personal opinion, and probably the majority of engineers today would agree, is that the representation of a heterogeneous multicentric world computer is better implemented in Polkadot. However, we will still go through the terms inherited from Ethereum, but towards the end of this part of the lecture.": "우리 블록이 형성되는 방식입니다. 상상해보세요: 버스가 도착하고 각 사람이 한 명씩 탑승하여 자리를 차지합니다. 그런 다음 버스는 경로를 따릅니다. 우리의 경우, 정보 블록은 첫 번째 경계를 극복합니다. 우리의 거래는 어떤 형태로든 버스에 안착하고 초기 장벽을 극복했습니다. 나는 주로 Polkadot에서 용어를 사용할 것이며, 세 번째 부분에서는 이더리움과 Polkadot 간의 세계 컴퓨터 개념을 더 잘 설명해야 합니다. 내 개인적인 의견은 오늘날 대부분의 엔지니어들이 동의할 것이며, 이질적 다중 중심 세계 컴퓨터의 표현이 Polkadot에서 더 잘 구현되었다고 생각합니다. 그러나 우리는 여전히 이더리움에서 상속된 용어를 살펴볼 것이며, 강의 이 부분의 끝쪽으로 갈 것입니다.",
  "What is the line that separates the bus stop from the bus's further movement? This line represents the collators of the network – participants in the network nodes who collect transactions. You can think of a collator not as a bus driver but as a controller who stays at the bus stop. In other words, this controller checks whether you have a ticket when you enter the bus. It doesn't recheck in the database how valid the ticket is but looks at the basic parameters of the ticket and checks if everything seems fine. In reality, collators perform almost all the calculations required, verifying the ticket number and other data, but they are not required to guarantee that the check is done correctly. Therefore, collators are controllers who remain at the bus stop, primarily ensuring passenger boarding, seating, and sending the bus further along the route.": "버스 정류장과 버스의 추가 이동을 구분하는 선은 무엇인가요? 이 선은 네트워크의 콜렉터를 나타냅니다 - 거래를 수집하는 네트워크 노드의 참여자들입니다. 콜렉터를 버스 운전사가 아닌 버스 정류장에 머무는 컨트롤러로 생각할 수 있습니다. 다시 말해, 이 컨트롤러는 당신이 ��스에 탑승할 때 티켓이 있는지 확인합니다. 데이터베이스에서 티켓이 유효한지 다시 확인하지 않지만 티켓의 기본 매개변수를 확인하고 모든 것이 괜찮아 보이는지 확인합니다. 실제로 콜렉터는 필요한 거의 모든 계산을 수행하며 티켓 번호 및 기타 데이터를 확인하지만 이 계산이 올바르게 수행되었는지 보장할 필요는 없습니다. 따라서 콜렉터는 버스 정류장에 머무는 컨트롤러로, 주로 승객 탑승, 좌석 배정 및 버스를 경로 상으로 전송하는 것을 보장합니다.",
  "Beyond the drawn border, we enter the first validation area where paravalidators are located. These are validators of the entire ecosystem, the entire network, specifically assigned for a certain time to check each transaction and thus perform actual computations in the world computer. Our not-yet-fully-formed block of information is marked with a dashed line. It is still a candidate block of information since it has not undergone any actual verification. The collator, who collected the block of information and checked the transactions at the entrance, does not participate in any way in securing the cybersecurity of the computations conducted. Its task is only to seat all transactions and form the first block. At this stage, the transformation from a candidate to a real block of information begins.": "그린 경계를 넘어 우리는 파라밸리데이터가 위치한 첫 번째 유효성 검사 영역에 들어갑니다. 이들은 전체 생태계, 전체 네트워크의 유효성 검사자로, 각 거래를 확인하기 위해 특정 시간 동안 할당된 유효성 검사자입니다. 아직 완전히 형성되지 않은 정보 블록은 점선으로 표시됩니다. 실제 확인을 거치지 않은 후보 정보 블록이기 때문입니다. 정보 블록을 수집하고 입구에서 거래를 확인한 콜렉터는 수행되는 계산의 사이버 보안을 보장하는 방식으로 참여하지 않습니다. 그의 임무는 모든 거래를 안착시키고 첫 번째 블록을 형성하는 것뿐입니다. 이 단계에서 후���에서 실제 정보 블록으로의 변환이 시작됩니다.",
  "I have divided it into three parts, but forgot one more. Let's consider four parts of this candidate block. The top part, known to users of various web3 applications as the header or block header, is the quintessence, the most popular piece of information circulating and reflected from the block explorer to the console clients of all nodes mining, staking, and so on. The header is a key element of the block, but it is practically formed at the last stage at this point.": "세 부분으로 나누었지만 하나를 잊었습니다. 이 후보 블록의 네 부분을 고려해 봅시다. 상단 부분은 다양한 웹3 애플리케이션 사용자들에게 헤더 또는 블록 헤더로 알려져 있으며, 블록 익스플로러에서 콘솔 클라이언트로 전파되고 모든 노드의 채굴, 스테이킹 등에서 반영되는 정보의 핵심이자 가장 인기 있는 정보입니다. 헤더는 블록의 핵심 요소이지만 현재 이 시점에서 거의 마지막 단계에서 형성됩니다.",
  "Firstly, we have our actual requests for state transitions or computations. There is a list of changes that need to be made: convert A to A', B to B', C to C', applying a set of algorithms to them. For this, we will now build another boundary immediately and go beyond it to perform this part of the work, and then only proceed beyond it. Already at the block preparation stage, we have to cross the second boundary within the world computer to go for the algorithms that need to be applied to prepare the block. As I mentioned before, theoretically, the controller at the bus stop here does the same, but I wouldn't pay much attention to that. The block preparation stage, especially when we talk about examples simultaneously from Polkadot and Ethereum as a world computer, they differ slightly and show us the insignificance of checks at this stage because it is precisely on the second step, after passing the first boundary and receiving the block of information from collators, that the attention-worthy calculations of this world computer begin.": "먼저, 상태 전이나 계산을 위한 실제 요청이 있습니다. A를 A'로, B를 B'로, C를 C'로 변환해야 하는 변경 목록이 있습니다. 이를 위해 우리는 즉시 다른 경계를 구축하고 이 작업의 일부를 수행하기 위해 그 경계를 넘어가야 하며, 그 후에만 그 경계를 넘어가야 합니다. 이미 블록 준비 단계에서 우리는 블록을 준비하기 위해 적용해야 하는 알고리즘으로 가기 위해 세계 컴퓨터 내에서 두 번째 경계를 넘어가야 합니다. 앞서 언급했듯이, 여기서 버스 정류장의 컨트롤러는 이와 같은 작업을 수행하지만 그것에는 크게 신경 쓰지 않을 것입니다. 특히 Polkadot과 이더리움을 동시에 세계 컴퓨터로서의 예제로 언급할 때, 이 단계에서의 확인의 중요성이 약간 다르며 이 세계 컴퓨터의 이 단계에서의 계산의 중요성을 보여줍니다.",
  "To perform these calculations, the validator, at this stage, can only do so by turning to the relay chain, the central database, and taking from there the algorithms from the runtime. In the case of Ethereum, it was the same virtual machines in the previous architectural concept, which could be applied, so there was no need to go anywhere. Almost every node had a complete copy of the algorithms that could be applied. But in terms of a heterogeneous network, where each segment or each individual chain may have its own set of algorithms, a validator, before actually executing all the transitions, calculations obtained in the form of a block candidate from the collator, must consult. It must consult the relay chain, consult the main blockchain in the network and take from there the necessary algorithms, apply them, and perform state transitions.": "이러한 계산을 수행하기 위해 검증자는 현재 단계에서 릴레이 체인, 중앙 데이터베이스에 의존하여 런타임에서 알고리즘을 가져와야 합니다. 이더리움의 경우, 이전의 아키텍처 개념과 동일한 가상 머신이었으므로 적용할 수 있었기 때문에 어디로 가야 할 필요가 없었습니다. 거의 모든 노드가 적용할 수 있는 알고리즘의 완전한 복사본을 가지고 있었습니다. 그러나 각 세그먼트 또는 각 개별 체인이 자체 알고리즘 세트를 가질 수 있는 이종 네트워크의 경우, 실제로 모든 전환, 콜렉터로부터 블록 후보 형태로 얻은 계산을 실행하기 전에 검증자는 상담해야 합니다. 릴레이 체인을 상담하고 네트워크의 주요 블록체인을 상담하고 거기서 필요한 알고리즘을 가져와 적용하고 상태 전환을 수행해야 합니다.",
  "During the execution of calculations, a Merkle tree is simultaneously formed, and we won't dwell on it because Merkle trees are not that complicated from the perspective of computer science. Still, I notice that to understand how to apply them in engineering and in the architecture of a project, how they are applied, not just by reading on Wikipedia, you need to break your head a bit, imagine examples. In this example, we won't delve too much into it, but I think for those who are already familiar with some basic definitions, have read about Merkle trees, it will become a bit clearer about how and at what moments another Merkle tree is assembled. The Merkle tree is formed when we actually perform calculations and output values appear. These output values are packed into a binary tree format, then the addition is performed between them in computer science language, and the top node reaches the header. Let's denote it with a big letter \"H.\" It's a small and pleasant aspect of considering such schemes.": "계산 실행 중에 Merkle 트리가 동시에 형성되며, 컴퓨터 과학적 관점에서 Merkle 트리는 그다지 복잡하지 않기 때문에 이에 대해 자세히 다루지 않겠습니다. 그럼에도 불구하고 엔지니어링 및 프로젝트 아키텍처에 적용하는 방법, 어떻게 적용되는지를 이���하려면 Wikipedia에서만 읽는 것이 아니라 조금 머리를 써서 예제를 상상해야 합니다. 이 예에서는 그것에 대해 너무 깊이 파고들지 않겠지만, 일부 기본적인 정의에 이미 익숙한 사람들에게는 Merkle 트리에 대해 읽었을 때 다른 Merkle 트리가 어떤 순간에 어떻게 조립되는지에 대해 조금 더 명확해질 것이라고 생각합니다. Merkle 트리는 실제 계산을 수행하고 출력 값이 나타날 때 형성됩니다. 이러한 출력 값은 이진 트리 형식으로 패킹되고, 그런 다음 컴퓨터 과학 언어로 그들 사이에서 추가가 수행되며, 최상위 노드가 헤더에 도달합니다. 이를 대문자 \"H\"로 표시해 봅시다. 이러한 체계에서 블록 헤더가 실제로 내부에서 수행된 계산과 관련이 있는 방법을 알 수 있습니다. 다시 한번 살펴보겠습니다 - 우리의 블록 후보는 콜렉터로부터 왔습니다. 실행해야 할 트랜잭션 세트가 있고, 계산을 수행해야 합니다. 검증자는 다른 내부 경계를 통과했고, 알고리즘 뒤에 하나 더, 그것을 적용하고, 모든 결과를 Merkle 트리의 가장 낮은 수준에 기록했습니다. 다른 노드들은 본질적으로 체계적입니다. 어떤 데이터에서도 나오지 않습니다; 어디에서도 나오지 않습니다. 두 번째 수준에서 노드는 어떤 정보에서도 나오지 않습니다. 이 두 잎에서 값들을 합산하여 얻으며, 우리가 함께 위로 올라갈 때, 우리는 이 트리의 루트만 얻게 됩니다. 이것은 모든 출력 값들을 보호하는 데 충분합니다. 이러한 계산 중 하나라도 변경하면 동일한 헤더를 얻지 못할 것입니다. 이것은 하나의 헤더에 대해 이야기함으로써 전체 블록 정보를 어떻게 보호할 수 있는지에 대한 마법과 간단한 기능 중 하나입니다. 따라서 헤더는 그렇게 중요하며, 한 체인이나 하나의 가상 머신에서 여러 개로 네트워크에 결합할 때 아키텍처에서 전환할 때도 중심적인 역할을 합니다. 헤더를 저장하는 보안을 보장하기만 하면, 블록 준비 단계에서 실행된 모든 트랜잭션이 올바르게 실행되었고, 그것들을 대체할 수 없다는 것을 확신할 수 있습니다.",
  "In this scheme, we can note how the block header is actually related to the computations performed inside. Let's look again - our block candidate came from the collator. There is a set of transactions that need to be executed, perform calculations. The validator went through another internal boundary, one more, behind the algorithms, applied them, and recorded all the results at the lowest level of the Merkle tree. The other nodes are essentially systemic. They do not come from any data; they don't come from anywhere. At the second level, the node does not come from any information. It is obtained by summing values in these two leaves, and when we go up with you, we get only the root of this tree, which is enough to protect all output values. We won't get the same header if we change any of these calculations. And this is one of the magical and simple features, like hash-oriented storage, of how we can protect a whole block of information by talking only about one header. Therefore, headers are so important and play a cornerstone role even in architectures when we transition from one chain or one virtual machine to many combined in the network. It is enough for us to ensure the security of storing headers to be sure that all transactions that were executed at the block preparation stage were executed correctly, and they cannot be replaced.": "이 계획에서는 블록 헤더가 실제로 내부에서 수행된 계산과 관련이 있는지에 대해 알아볼 수 있습니다. 다시 한번 살펴보겠습니다 - 우리의 블록 후보는 콜렉터로부터 왔습니다. 실행해야 할 트랜잭션 세트가 있고, 계산을 수행합니다. 검증자는 다른 내부 경계를 통과했고, 알고리즘 뒤에 하나 더, 그것을 적용하고 모든 결과를 Merkle 트리의 가장 낮은 수준에 기록했습니다. 다른 노드들은 본질적으로 체계적입니다. 어떤 데이터에서도 나오지 않습니다; 어디서도 나오지 않습니다. 두 번째 수준에서 노드는 어떤 정보에서도 나오지 않습니다. 이 두 잎의 값을 합산하여 얻으며, 우리가 함께 올라갈 때, 우리는 이 트리의 루트만 얻게 되는데, 이것은 모든 출력 값을 보호하는 데 충분합니다. 이러한 계산 중 하나라도 변경하면 동일한 헤더를 얻지 못할 것입니다. 이것은 해시 지향 저장과 같은 마법과 간단한 기능 중 하나이며, 우리가 한 헤더에 대해 이야기함으로써 전체 정보 블록을 어떻게 보호할 수 있는지에 대한 것입니다. 따라서 헤더는 중요하며, 한 체인���나 네트워크에 결합된 여러 가상 머신으로 전환할 때에도 중추적인 역할을 합니다. 헤더를 저장하는 보안을 보장하기만 하면, 블록 준비 단계에서 실행된 모든 트랜잭션이 올바르게 실행되었음을 확신할 수 있습니다. 그리고 그것들은 대체할 수 없습니다.",
  "And one field is still left unfilled. In the process of preparing the block of information, it is the author's field, that is, the validator who actually performed all the changes, prepared the Merkle tree, and recorded the header. Since we are considering an example with the bus moving along the route from the stop, let's call the validator a \"controller\" who goes right inside the bus, passes each seat, approaches each person, checks for real what is written on their tickets, makes some mark, validates it, and, accordingly, puts their signature. The controller, for example, number 134, meaning, naturally, each validator has some unique identifier, their address, and we also somehow uniquely renamed it here.": "그리고 아직 채워지지 않은 필드 하나가 남아 있습니다. 정보 블록을 준비하는 과정에서, 저자의 필드, 즉 실제로 모든 변경을 수행하고 Merkle 트리를 준비하고 헤더를 기록한 검증자입니다. 정류장에서 노선을 따라 이동하는 버스의 예제를 고려할 때, 검증자를 \"컨트롤러\"라고 부르겠습니다. 컨트롤러는 버스 안으로 직접 들어가 각 좌석을 지나가며 각 사람에게 다가가서 티켓에 적힌 내용을 직접 확인하고 표시를 하고 유효성을 검사하고, 그에 따라 서명을 남깁니다. 예를 들어, 134번이라는 컨트롤러가 있고, 당연히 각 검증자에게는 고유한 식별자, 주소가 있으며, 우리는 여기서 어떤 방식으로든 고유하게 이름을 지었습니다.",
  "And it seems that at this point, we could have shaded and made our block boundaries bolder, but no, and this is one of the interesting changes that have occurred in the last 5 years in terms of decentralized ecosystems, namely the shift from proof of work. When validators of the network, at that time miners, never had to coordinate anything with each other. You produced a block and sent it to the network and moved on. In fact, it was not a consensus of agreed consent. It was a consensus of obvious agreement with the fact that had occurred. What is interesting changes when the architecture becomes more complex, and we have come closer from a simple calculator like Bitcoin with a ledger towards an actual virtual computer, is that at each stage, the connectivity of participants who ensure security and block production has increased. Because, in fact, no one who risks their stake, the one who ensures this security and wants to earn by processing your transactions, has something to lose, unlike proof of work. In proof of work, you bought the equipment, yes, you put money into it, you spend electricity, but there is actually no protection against the fact that you can attack the network with your power, the same 51% attack, where someone with a lot of miners can try to rewrite the chain.": "그리고 이 시점에서 우리는 블록 경계를 더 짙게 그릴 수 있었을 것 같지만, 아니요, 이것은 분산 생태계에서 지난 5년 동안 발생한 흥��로운 변화 중 하나입니다. 즉, 작업 증명에서의 변화로부터의 이동입니다. 네트워크의 검증자들, 당시 채굴자들은 서로 조정할 필요가 없었습니다. 블록을 생성하고 네트워크로 보내고 넘어갔습니다. 사실, 합의된 동의의 합의가 아니었습니다. 발생한 사실에 대한 명백한 합의의 합의였습니다. 아키텍처가 더 복잡해지고, 우리가 비트코인과 원장과 같은 간단한 계산기에서 실제 가상 컴퓨터로 가까워질 때, 각 단계에서 보안과 블록 생성을 보장하는 참여자들의 연결성이 증가했습니다. 실제로, 자신의 지분을 위험에 빠뜨리는 사람은 아무도 없으며, 이 보안을 보장하고 귀하의 트랜잭션을 처리하여 수익을 얻고자 하는 사람은 작업 증명과는 달리 아무것도 잃을 것이 없습니다. 작업 증명에서는 장비를 구입했고, 네, 돈을 투자했고, 전기를 소비했지만, 실제로는 당신이 네트워크를 공격할 수 있다는 사실에 대한 보호가 없습니다. 많은 채굴자를 가진 사람이 동일한 51% 공격을 시도할 수 있는 것과 같은 공격이 가능합니다.",
  "Now we are talking about proof of stake, where a deposit is already made, and if you do something wrong, a part will be withdrawn from it, as a penalty. All nodes, absolutely, in all architectures that I currently observe, mechanisms for messaging between validators began to appear quickly at the block preparation stage. In Polkadot, it is no different. Any validator of a separate parachain that collects a block knows the addresses or already has established contact with another 15-63 validators who are with you on this epoch, on some temporary period, as validators, and each of them randomly becomes a block producer at some point. But being appointed as a producer does not negate a very important component of this process. You do not stop interacting with the other participants. There is always a pool of validators assigned to a specific epoch, to a certain time slot, for validating a particular parachain or segment of the world computer. Regardless of whether you are a validator-controller specifically assigned to produce the next block in the world computer of this segment, you still stay in touch with the other validators, and you have constant contact with them.": "지금 우리는 지분 증명에 대해 이야기하고 있습니다. 여기에는 이미 예금이 되어 있으며, 잘못된 일을 하면 일부가 벌금으로 인출됩니다. 현재 내가 관찰하는 모든 아키텍처에서 모든 노드는 블록 준비 단계에서 검증자 간 메시징 메커니즘이 빠르게 나타나기 시작했습니다. Polkadot에서도 마찬가지입니다. 특정 파라체인의 모든 검증자는 블록을 수집하고 이미 이 에포크에서 당신과 함께하는 다른 15-63명의 검증자의 주소를 알고 있거나 이미 연락을 맺었습니다. 일시적으로 검증자로서, 그리고 그 중 한 명이 언젠가 블록 프로듀서가 됩니다. 그러나 프로듀서로 지명되더라도이 프로세스의 매우 중요한 구성 요소를 무효화하지는 않습니다. 다른 참가자들과 상호 작용을 중단하지 않습니다. 특정 에포크, 특정 시간 슬롯, 특정 파라체인 또는 세계 컴퓨터 세그먼트를 검증하기 위해 할당된 검증자 풀이 항상 있습니다. 이 세그먼트의 세계 컴퓨터에서 다음 블록을 생성하도록 명시적으로 지정된 검증자-컨트롤러이든, 여전히 다른 검증자들과 연락을 유지하며 항��� 그들과 연락을 취합니다.",
  "Why is this constant contact necessary? It turns out to be quite simple. We do not want, when we move into the inner part, to be afraid or worry that we performed any of the operations incorrectly. As surprising as it may seem, it is beneficial for any validator, before moving on, to first turn to their colleagues assigned to validation and ask them to double-check the calculations. This check is informal, so even if we do not use any logging into an immutable database of requests for verification and the results of this verification, the appointed controller, after talking to the pool of validators, still collects additional responses from all validators assigned to this parachain or network segment. Together with additional confirmations, the controller moves on to the next stage. But even here, it's not quite as simple. At this stage, another process has to be performed. It is important to note that at this stage, our block of information is still a candidate block, and settlement of information is already taking place in the storage. Neither at the very end, nor after we have created and sealed the block and attached it with an archiver in the final part, namely here, in this middle part where all the calculations are actually performed, does the information get saved in the storage. Therefore, our controller, in addition to talking to their colleagues, also ensures the storage of data in some storage, which is also quite metaphysical because the moment you communicate with other validators, this storage gets filled. How is this checked? We will need to move on to the next stage.": "왜 이 지속적인 연락이 필요한가요? 이는 꽤 간단한 것으로 밝혀졌습니다. 우리는 내부로 이동할 때 우리가 어떤 작업을 잘못 수행했는지 두려워하거나 걱정하지 않기를 원하지 않습니다. 놀랍게도, 어떤 유효성 검사자에게든, 다음 단계로 넘어가기 전에 먼저 유효성 검사에 할당된 동료들에게 연락하여 계산을 두 번 확인해달라고 요청하는 것이 유익합니다. 이 확인은 비공식적이므로 우리가 검증 요청과 이 검증 결과의 불변 데이터베이스에 로깅을 사용하지 않더라도, 지정된 컨트롤러는 여전히 유효성 검사자 풀과 대화한 후 이 패러체인 또는 네트워크 세그먼트에 할당된 모든 유효성 검사자로부터 추가 응답을 수집합니다. 추가 확인과 함께 컨트롤러는 다음 단계로 이동합니다. 그러나 여기서도 그렇게 간단하지는 않습니다. 이 단계에서 다른 프로세스를 수행해야 합니다. 이 단계에서 우리의 정보 블록은 여전히 후보 블록이며, 정보의 정산은 이미 저장소에서 진행 중입니다. 매우 끝이나 블록을 생성하고 아카이버와 함께 최종 부분에 첨부한 후에도, 즉 여기, 모든 계산이 실제로 수행되는 중간 부분에서는 정보가 저장소에 저장되지 않습니다. 따라서 우리의 컨트롤러는 동료들과 대화하는 것 외에도 어떤 저장소에 데이터를 저장하는지 확인합니다. 이 저장소는 다른 유효성 검사자와 통신할 때 채워지기 때문에 꽤 형이상학적입니다. 이 확인은 어떻게 이루어지나요? 다음 단계로 넘어가야 할 것입니다.",
  "In summary, to complete the middle part, let's look again. We still have only a candidate block at the very beginning. Yes, all transactions are roughly calculated somewhere at the bus stop, everyone has taken their seats according to their tickets. We have passed the first boundary, which is essentially direct established contact between validators and block collators. In Ethereum and Polkadot, these are slightly different schemes now. But everything that happens on the left side at the very beginning does not provide cybersecurity for data and calculations. It's just preparation. Once we have passed and entered the environment of the validators' attention, work with the block of information in the world computer begins. A randomly selected validator, in our case, with a bus route - a controller, actually goes through each of the seats, checks the ticket, checks and performs all the calculations that were made, gathers all the information into a tree. The resulting root node of this tree becomes the header of the proposed block. The validator who actually performs all the calculations with this block of information communicates with the other participants who perform a similar function for the same route in an undefined time slot. And while communicating with them and asking them to verify all the calculations, we are actually filling a certain storage of data in the network. It is not a specific physical storage; there is no specific IP address, no specific hard drive onto which they all load through some VPN or login and password scheme, of course not. In the process of communicating with other validators, data remains on their local machines, and this data will further participate in the transformation of this candidate into a new block of information. In essence, the sealed block that will be settled in the relay chain is collected. We have assembled a block. All the metadata around the calculations is already filled, which means we can try to move on to the next frontier.": "요약하자면, 중간 부분을 완료하기 위해 다시 한번 살펴봅시다. 여전히 맨 처음에는 후보 블록만 있습니다. 네, 모든 거래는 버스 정류장 어딘가에서 대략적으로 계산되고, 모든 사람들은 티켓에 따라 자리에 앉았습니다. 우리는 실제로 검증자와 블록 콜렉터 간의 직접적인 연락이 확립된 첫 번째 경계를 통과했습니다. 이제 이더리움과 폴카닷에서는 약간 다른 체계입니다. 그러나 처음에 왼쪽에서 일어나는 모든 일은 데이터와 계산에 대한 사이버 보안을 제공하지 않습니다. 그것은 준비일 뿐입니다. 한 번 검증자들의 주의를 끌고 환경에 들어가면, 세계 컴퓨터에서 정보 블록을 처리하기 시작합니다. 우리 경우에는 무작위로 선택된 검증자가 버스 노선을 통해 각 좌석을 실제로 통과하며 티켓을 확인하고 모든 계산을 수행하고 모든 정보를 트리로 수집합니다. 이 트리의 결과 루트 노드가 제안된 블록의 헤더가 됩니다. 이 정보 블록과 모든 계산을 실제로 수행하는 검증자는 정의되지 않은 시간대에 동일한 노선에 대해 유사한 기능을 수행하는 다른 참가���들과 통신합니다. 그들과 통신하면서 모든 계산을 확인하도록 요청함으로써 네트워크의 데이터 저장소를 채우게 됩니다. 이것은 특정한 물리적 저장소가 아닙니다; 특정 IP 주소도 없고, 특정 하드 드라이브도 없습니다. 다른 검증자들과 통신하는 과정에서 데이터는 그들의 로컬 기기에 남아 있고, 이 데이터는 나중에 이 후보를 새로운 정보 블록으로 변환하는 과정에 참여하게 됩니다. 본질적으로 릴레이 체인에 정착될 밀봉된 블록이 수집됩니다. 우리는 블록을 조립했습니다. 계산 주변의 모든 메타데이터가 이미 채워졌으므로 다음 단계로 나아갈 수 있습니다.",
  "At this moment, let's delve into the passage of the next boundary. The most crucial aspect at the final stage becomes the block header. We are less concerned with the execution of computations; we can simplify our perspective here, as computations may vary based on the architecture, whether it's Ethereum or Polkadot. The key point is that, on the intermediate stage, from what I observe in the theory and practice of implementing the world computer concept, most computations happen at an intermediate level. The last level remains only to execute essential checks. Almost all these checks in a multi-chain architecture are related to the concatenation or merging of block headers into one block.": "이 순간에는 다음 경계를 통과하는 것에 대해 심층적으로 파고들어 봅시다. 마지막 단계에서 가장 중요한 측면은 블록 헤더가 됩니다. 계산 실행에 대해 덜 걱정해도 됩니다; 여기서 우리의 시각을 단순화할 수 있습니다. 계산은 이더리움이나 폴카닷과 같은 아키텍처에 따라 다양할 수 있기 때문입니다. 중간 단계에서 중요한 점은, 세계 컴퓨터 개념을 구현하는 이론과 실천에서 내가 관찰한 바에 따르면, 대부분의 계산이 중간 수준에서 발생한다는 것입니다. 마지막 닠은 필수적인 확인만 실행하는 것으로 남아 있습니다. 다중 체인 아키텍처에서 이러한 모든 확인 대부분은 블록 헤더를 하나의 블록으로 연결하거나 병합하는 것과 관련이 있습니다.",
  "In the final part of our journey, the most important element in the world computer's information block becomes the cornerstone – the header. The second component is more about meta-information. If the header is the actual result of all computations, the additional meta-information being transmitted consists of receipts and signatures of the validators who participated in the intermediate stage of this process. At the final stage, we can visualize the whole picture solely as the assembly of the same tree, not as a list of transactions. In the relay chain's final part, the crucial aspect is the assembly of headers from many similar processes, but linked to different segments of the world computer, different parachains.": "우리 여행의 마지막 부분에서 세계 컴퓨터 정보 블록에서 가장 중요한 요소는 기반 – 헤더가 됩니다. 두 번째 구성 요소는 메타 정보에 대해 더 많이 이야기합니다. 헤더가 모든 계산의 실제 결과인 경우, 전달되는 추가 메타 정보는 중간 단계에서 참여한 검증자들의 영수증 및 서명으로 구성됩니다. 최종 ��계에서 우리는 전체 그림을 단순히 동일한 트리의 조립으로만 시각화할 수 있습니다. 트랜잭션 목록으로 보는 것이 아니라. 릴레이 체인의 마지막 부분에서 중요한 측면은 많은 유사한 프로세스에서 헤더를 조립하는 것입니다. 그러나 세계 컴퓨터의 다른 세그먼트에 연결된 다른 프로세스에서 헤더를 조립하는 것입니다.",
  "Each parachain, each set of validators – we've discussed one example, but in reality, such block preparations for parachains happen 30-40 times. The number of parachain slots or the number of L2 networks in Ethereum will result in a similar number of processes with a similar architecture. However, in the final stage, we will see an approximately identical picture everywhere – how the block header will be formed from a multitude of headers from other blocks. In this process, we need to introduce one more entity and jump back across the boundary to the second stage.": "각 파라체인, 각 검증자 세트 – 우리는 한 예제에 대해 논의했지만 실제로는 파라체인을 위한 이러한 블록 준비가 30-40번 발생합니다. 이더리움의 파라체인 슬롯 수나 L2 네트워크 수는 유사한 아키텍처의 유사한 프로세스 수를 야기할 것입니다. 그러나 최종 단계에서 우리는 거의 동일한 그림을 어디서나 볼 수 있을 것입니다 – 블록 헤더가 다른 블록의 많은 헤더에서 형성될 것입니다. 이 과정에서 우리는 하나의 엔티티를 소개하고 두 번째 단계로 다시 건너뛰어야 합니다.",
  "Finalizers. In fact, they are also validators, but relay chain validators. In the Polkadot architecture, we have a thousand validators divided into two groups. The first, a very small group, is responsible only for forming the block header and a new block consisting of the headers of the State of the States blocks. The second group – parachain validators – is further divided into many subgroups, but this group is called parachain validators. In L2 networks above Ethereum, this story will eventually gain more understanding, more denominators. For now, let's focus on the Polkadot architecture. Finalizers, besides checking an additional set of meta-information and rechecking a validator with a specific ID, randomly chosen to generate this block of all blocks, also help recheck meta-information, check, and assemble all headers into one. It's a bit complex, yes, if we look at it from the perspective of tree assembly.": "파이널라이저. 사실, 그들도 검증자이지만 릴레이 체인 검증자입니다. 폴카닷 아키텍처에서 우리는 두 그룹으로 나뉜 천 개의 검증자가 있습니다. 첫 번째, 매우 작은 그룹은 블록 헤더를 형성하고 상태 블록의 헤더로 구성된 �� 블록에만 책임이 있습니다. 두 번째 그룹 – 파라체인 검증자 –는 여러 하위 그룹으로 나뉘지만 이 그룹은 파라체인 검증자라고 불립니다. 이더리움 위의 L2 네트워크에서는 이 이야기가 더 많은 이해, 더 많은 분모를 얻게 될 것입니다. 지금은 폴카닷 아키텍처에 집중해 봅시다. 파이널라이저는 모든 블록 중 하나를 생성하기 위해 임의로 선택된 특정 ID의 검증자를 다시 확인하고 추가 메타 정보를 확인하고 모든 헤더를 하나로 조립하는 데 도움이 되는 검증자입니다. 조금 복잡하죠, 네, 트리 조립의 관점에서 바라본다면.",
  "In addition to this, in the Polkadot architecture and in Ethereum with the latest changes, a data availability check takes place. For this, finalizers visit parachain validators and try to request actual information about each block stored in the network. If they receive data from at least 1/3 of the validators, using technology that allows redundant storage of information, and subsequently, if someone loses it, one or two or three validators can still restore it, there is a critical threshold at 1/3. If 1/3 of the nodes respond and say that we have data about the block being produced, finalizers tell the block that it is already a fully formed information block, that all computations have been done correctly, that we have already taken the header of this block and combined it with someone else's headers from other segments of the network. We have already formed the main header of the entire network. After that, finalizers place many checkmarks on the final block, which combines all performed computations.": "이 외에도, Polkadot 아키텍처와 최신 변경 사항이 있는 이더리움에서 데이터 가용성 확인이 이루어집니다. 이를 위해 파이널라이저가 파라체인 밸리데이터를 방문하고 네트워크에 저장된 각 블록에 대한 실제 정보를 요청하려고 시도합니다. 밸리데이터 중 적어도 1/3에서 데이터를 수신하면 정보의 중복 저장을 허용하는 기술을 사용하여, 그 후에 누군가가 그것을 잃어버리면 1/2 또는 1/3의 밸리데이터가 여전히 복원할 수 있습니다. 1/3에서 임계값이 있습니다. 노드 중 1/3이 응답하여 생성 중인 블록에 대한 데이터가 있다고 말하면 파이널라이저는 이미 완전히 형성된 정보 블록이라고 블록에 알립니다. 모든 계산이 올바르게 수행되었고 이미 이 블록의 헤더를 가져와 네트워크의 다른 세그먼트의 다른 사람의 헤더와 결합했다고 말합니다. 이미 전체 네트워크의 주요 헤더를 형성했습니다. 그 후, 파이널라이저는 수행된 모든 계산을 결합한 최종 블록에 많은 체크마크를 놓습니다.",
  "Currently, this is the situation from the perspective of the most engineering-implemented multi-chain heterogeneous ecosystem, which is Polkadot. It is the most engineering-implemented multi-chain heterogeneous ecosystem, not too far from Ethereum. I would like to focus on the comparison, and if someone is interested in understanding how information blocks flow in Ethereum with L2 networks, you can try to do that now. I will return to this question when some elements of Ethereum, in terms of heterogeneity and multi-chain aspects, are completed. It might take 1-2 years, and then we can build such a picture. Nevertheless, we can generally accept a scheme with three main stages:": "현재, 이는 가장 공학적으로 구현된 멀티체인 이종 생태계인 Polkadot의 관점에서의 상황입니다. 이는 이더리움에서 너무 멀지 않은 가장 공학적으로 구현된 멀티체인 이종 생태계입니다. 비교에 초점을 맞추고, 누군가가 L2 네트워크를 통해 이더리움에서 정보 블록이 어떻게 흐르는지 이해하고 싶다면 지금 시도해 볼 수 있습니다. 이더리움의 이러한 요소들이 이종성과 멀티체인 측면에서 완료되면 이 질문으로 돌아갈 것입니다. 1-2년이 걸릴 수 있으며, 그런 다음에 그림을 그릴 수 있습니다. 그럼에도 불구하고, 일반적으로 세 가지 주요 단계를 수용할 수 있습니다.",
  "**1. Formation of a candidate for the information block:**": "**1. 정보 블록 후보 형성:**",
  "In this stage, the initial candidate for the information block is formed.": "이 단계에서는 정보 블록의 초기 후보가 형성됩니다.",
  "**2. Execution of all computations, data storage, data availability, rechecking with other nodes, ensuring that all state transitions are performed correctly according to specific algorithms, and storing these algorithms in the main citadel:**": "**2. 모든 계산, 데이터 저장, 데이터 가용성, 다른 노드와의 재확인, 모든 상태 전이가 특정 알고리즘에 따라 올바르게 수행되도록 보장하고 이러한 알고리즘을 본 요새에 저장:**",
  "This stage involves the actual execution of computations, saving data to certain layers, ensuring data availability, rechecking with other nodes to confirm that all state transitions are in accordance with algorithms stored somewhere in the main citadel.": "이 단계에는 실제 계산 실행, 데이터를 특정 레이어에 저장, 데이터 가용성 보장, 다른 노드와의 재확인을 포함하여 모든 상태 전이가 본 요새 어딘가에 저장된 알고리즘과 일치하는지 확인합니다.",
  "**3. Finalization, which will not recheck the computations but will verify the meta-information, how this meta-information is stored. It will then assemble the final block, which is the state of the states, and release it as a common information block for the entire segmented multi-chain network:**": "**3. 재확인하지 않을 계산을 마무리하고 메타 정보를 확인하고 이 메타 정보가 어떻게 저장되는지 확인합니다. 그런 다음 최종 블록을 조립하고, 이는 상태의 상태이며, 전체 분할된 멀티 체인 네트워크에 대한 공통 정보 블록으로 발표됩니다:**",
  "The final stage involves checking the meta-information, verifying how this meta-information is stored, assembling the final block (state of the states), and releasing it as a common information block for the entire segmented multi-chain network.": "최종 단계에는 메타 정보를 확인하고, 이 메타 정보가 어떻게 저장되는지 확인하고, 최종 블록(상태의 상태)을 조립하여 전체 분할된 멀티 체인 네트워크에 대한 공통 정보 블록으로 발표합니다.",
  "At this point, we can say that our information is saved. It has passed through the heart, the heart has executed its data transfer correctly, and we can already use the output values. Some will use them to open a smart-contract-purchased apartment with a smart lock, while others might show off their NFT, just received for 10 ethers.": "이 시점에서 우리의 정보가 저장되었다고 말할 수 있습니다. 그것은 중심을 통과했고, 중심은 데이터 전송을 올바르게 실행했으며, 우리는 이미 출력 값을 사용할 수 있습니다. 어떤 사람들은 스마트 락이 달린 스마트 계약으로 구입한 아파트를 열기 위해 사용할 것이고, 다른 사람들은 10 이더를 받은 방금 받은 NFT를 자랑스러워할 것입니다.",
  "In general, this is approximately how it works. This concludes the theoretical part. I think it took about 2 hours, and ahead of us are practical sessions that I will be recording over the next few months. They will help us understand the observed data from the console window, decentralized applications, block explorers, where we will gradually understand how all these theoretical numbers and letters actually look in implementation using Polkadot as an example. I will also start getting hands-on with implementations at the L2 level using one of the well-known frameworks for building L2. Thank you to everyone who has been watching.": "일반적으로 대략 이렇게 작동합니다. 이로써 이론적인 부분을 마칩니다. 약 2시간 정도 걸린 것 같고, 앞으로는 몇 달 동안 녹화할 실제 세션들이 우리 앞에 있습니다. 이들은 콘솔 창, 탈중앙화 애플리케이션, 블록 익스플로러에서 관찰된 데이터를 이해하는 데 도움이 될 것입니다. 여기서 모든 이론적인 숫자와 문자가 실제로 어떻게 구현되는지를 Polkadot을 예로 사용하여 이해할 것입니다. 나는 또한 L2를 구축하기 위한 잘 알려진 프레임워크 중 하나를 사용하여 L2 수준에서 직접 구현을 시작할 것입니다. 시청해 주신 모든 분들께 감사드립니다."
}